{
  "directories": [
    {
      "name": "src\\Generated\\Models",
      "files": [
        {
          "name": "ThingRequiredLiteralString.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralString",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_requiredLiteralString. \u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralString : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.ThingRequiredLiteralString\u003E\n    {\n        private readonly string _value;\n        /// \u003Csummary\u003E accept. \u003C/summary\u003E\n        private const string AcceptValue = \u0022accept\u0022;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022value\u0022/\u003E is null. \u003C/exception\u003E\n        public ThingRequiredLiteralString(string value)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(value, nameof(value));\n\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E accept. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString Accept { get; } = new global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString(AcceptValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString left, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString left, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString(string value) =\u003E new global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString other) =\u003E string.Equals(_value, other._value, global::System.StringComparison.InvariantCultureIgnoreCase);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E (_value != null) ? global::System.StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "ThingRequiredLiteralInt.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralInt",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_requiredLiteralInt. \u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralInt : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt\u003E\n    {\n        private readonly int _value;\n        /// \u003Csummary\u003E 123. \u003C/summary\u003E\n        private const int _123Value = 123;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingRequiredLiteralInt(int value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 123. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt _123 { get; } = new global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt(_123Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt left, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt left, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt(int value) =\u003E new global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt other) =\u003E int.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(global::System.Globalization.CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "ThingRequiredLiteralFloat.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralFloat",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_requiredLiteralFloat. \u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralFloat : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat\u003E\n    {\n        private readonly float _value;\n        /// \u003Csummary\u003E 1.23. \u003C/summary\u003E\n        private const float _123Value = 1.23F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingRequiredLiteralFloat(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 1.23. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat _123 { get; } = new global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat(_123Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat left, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat left, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat(float value) =\u003E new global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(global::System.Globalization.CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralString.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralString",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_optionalLiteralString. \u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralString : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.ThingOptionalLiteralString\u003E\n    {\n        private readonly string _value;\n        /// \u003Csummary\u003E reject. \u003C/summary\u003E\n        private const string RejectValue = \u0022reject\u0022;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022value\u0022/\u003E is null. \u003C/exception\u003E\n        public ThingOptionalLiteralString(string value)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(value, nameof(value));\n\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E reject. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString Reject { get; } = new global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString(RejectValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString left, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString left, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString(string value) =\u003E new global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString other) =\u003E string.Equals(_value, other._value, global::System.StringComparison.InvariantCultureIgnoreCase);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E (_value != null) ? global::System.StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralInt.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralInt",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_optionalLiteralInt. \u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralInt : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt\u003E\n    {\n        private readonly int _value;\n        /// \u003Csummary\u003E 456. \u003C/summary\u003E\n        private const int _456Value = 456;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingOptionalLiteralInt(int value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 456. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt _456 { get; } = new global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt(_456Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt left, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt left, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt(int value) =\u003E new global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt other) =\u003E int.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(global::System.Globalization.CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralFloat.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralFloat",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_optionalLiteralFloat. \u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralFloat : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat\u003E\n    {\n        private readonly float _value;\n        /// \u003Csummary\u003E 4.56. \u003C/summary\u003E\n        private const float _456Value = 4.56F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingOptionalLiteralFloat(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 4.56. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat _456 { get; } = new global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat(_456Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat left, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat left, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat(float value) =\u003E new global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(global::System.Globalization.CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "StringFixedEnum.cs",
          "typeDeclaration": {
            "name": "StringFixedEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Simple enum. \u003C/summary\u003E\n    public enum StringFixedEnum\n    {\n        /// \u003Csummary\u003E One. \u003C/summary\u003E\n        One,\n        /// \u003Csummary\u003E Two. \u003C/summary\u003E\n        Two,\n        /// \u003Csummary\u003E Four. \u003C/summary\u003E\n        Four\n    }\n}\n"
          }
        },
        {
          "name": "StringExtensibleEnum.cs",
          "typeDeclaration": {
            "name": "StringExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Extensible enum. \u003C/summary\u003E\n    public readonly partial struct StringExtensibleEnum : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.StringExtensibleEnum\u003E\n    {\n        private readonly string _value;\n        private const string OneValue = \u00221\u0022;\n        private const string TwoValue = \u00222\u0022;\n        private const string FourValue = \u00224\u0022;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022value\u0022/\u003E is null. \u003C/exception\u003E\n        public StringExtensibleEnum(string value)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(value, nameof(value));\n\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the One. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.StringExtensibleEnum One { get; } = new global::UnbrandedTypeSpec.Models.StringExtensibleEnum(OneValue);\n\n        /// \u003Csummary\u003E Gets the Two. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.StringExtensibleEnum Two { get; } = new global::UnbrandedTypeSpec.Models.StringExtensibleEnum(TwoValue);\n\n        /// \u003Csummary\u003E Gets the Four. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.StringExtensibleEnum Four { get; } = new global::UnbrandedTypeSpec.Models.StringExtensibleEnum(FourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.StringExtensibleEnum left, global::UnbrandedTypeSpec.Models.StringExtensibleEnum right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.StringExtensibleEnum left, global::UnbrandedTypeSpec.Models.StringExtensibleEnum right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.StringExtensibleEnum(string value) =\u003E new global::UnbrandedTypeSpec.Models.StringExtensibleEnum(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.StringExtensibleEnum other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.StringExtensibleEnum other) =\u003E string.Equals(_value, other._value, global::System.StringComparison.InvariantCultureIgnoreCase);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E (_value != null) ? global::System.StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "IntExtensibleEnum.cs",
          "typeDeclaration": {
            "name": "IntExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Int based extensible enum. \u003C/summary\u003E\n    public readonly partial struct IntExtensibleEnum : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.IntExtensibleEnum\u003E\n    {\n        private readonly int _value;\n        private const int OneValue = 1;\n        private const int TwoValue = 2;\n        private const int FourValue = 4;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.IntExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public IntExtensibleEnum(int value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the One. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.IntExtensibleEnum One { get; } = new global::UnbrandedTypeSpec.Models.IntExtensibleEnum(OneValue);\n\n        /// \u003Csummary\u003E Gets the Two. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.IntExtensibleEnum Two { get; } = new global::UnbrandedTypeSpec.Models.IntExtensibleEnum(TwoValue);\n\n        /// \u003Csummary\u003E Gets the Four. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.IntExtensibleEnum Four { get; } = new global::UnbrandedTypeSpec.Models.IntExtensibleEnum(FourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.IntExtensibleEnum\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.IntExtensibleEnum left, global::UnbrandedTypeSpec.Models.IntExtensibleEnum right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.IntExtensibleEnum\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.IntExtensibleEnum left, global::UnbrandedTypeSpec.Models.IntExtensibleEnum right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.IntExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.IntExtensibleEnum(int value) =\u003E new global::UnbrandedTypeSpec.Models.IntExtensibleEnum(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.IntExtensibleEnum other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.IntExtensibleEnum other) =\u003E int.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(global::System.Globalization.CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "FloatExtensibleEnum.cs",
          "typeDeclaration": {
            "name": "FloatExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Float based extensible enum. \u003C/summary\u003E\n    public readonly partial struct FloatExtensibleEnum : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u003E\n    {\n        private readonly float _value;\n        private const float OneDotOneValue = 1.1F;\n        private const float TwoDotTwoValue = 2.2F;\n        private const float FourDotFourValue = 4.4F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public FloatExtensibleEnum(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the OneDotOne. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.FloatExtensibleEnum OneDotOne { get; } = new global::UnbrandedTypeSpec.Models.FloatExtensibleEnum(OneDotOneValue);\n\n        /// \u003Csummary\u003E Gets the TwoDotTwo. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.FloatExtensibleEnum TwoDotTwo { get; } = new global::UnbrandedTypeSpec.Models.FloatExtensibleEnum(TwoDotTwoValue);\n\n        /// \u003Csummary\u003E Gets the FourDotFour. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.FloatExtensibleEnum FourDotFour { get; } = new global::UnbrandedTypeSpec.Models.FloatExtensibleEnum(FourDotFourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.FloatExtensibleEnum left, global::UnbrandedTypeSpec.Models.FloatExtensibleEnum right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.FloatExtensibleEnum left, global::UnbrandedTypeSpec.Models.FloatExtensibleEnum right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.FloatExtensibleEnum(float value) =\u003E new global::UnbrandedTypeSpec.Models.FloatExtensibleEnum(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.FloatExtensibleEnum other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.FloatExtensibleEnum other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(global::System.Globalization.CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "FloatExtensibleEnumWithIntValue.cs",
          "typeDeclaration": {
            "name": "FloatExtensibleEnumWithIntValue",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E float fixed enum. \u003C/summary\u003E\n    public readonly partial struct FloatExtensibleEnumWithIntValue : global::System.IEquatable\u003Cglobal::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue\u003E\n    {\n        private readonly float _value;\n        private const float OneValue = 1F;\n        private const float TwoValue = 2F;\n        private const float FourValue = 4F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public FloatExtensibleEnumWithIntValue(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the One. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue One { get; } = new global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue(OneValue);\n\n        /// \u003Csummary\u003E Gets the Two. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue Two { get; } = new global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue(TwoValue);\n\n        /// \u003Csummary\u003E Gets the Four. \u003C/summary\u003E\n        public static global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue Four { get; } = new global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue(FourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue left, global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue left, global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue(float value) =\u003E new global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(global::System.Globalization.CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "FloatFixedEnum.cs",
          "typeDeclaration": {
            "name": "FloatFixedEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E float fixed enum. \u003C/summary\u003E\n    public enum FloatFixedEnum\n    {\n        /// \u003Csummary\u003E OneDotOne. \u003C/summary\u003E\n        OneDotOne,\n        /// \u003Csummary\u003E TwoDotTwo. \u003C/summary\u003E\n        TwoDotTwo,\n        /// \u003Csummary\u003E FourDotFour. \u003C/summary\u003E\n        FourDotFour\n    }\n}\n"
          }
        },
        {
          "name": "FloatFixedEnumWithIntValue.cs",
          "typeDeclaration": {
            "name": "FloatFixedEnumWithIntValue",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E float fixed enum. \u003C/summary\u003E\n    public enum FloatFixedEnumWithIntValue\n    {\n        /// \u003Csummary\u003E One. \u003C/summary\u003E\n        One = 1,\n        /// \u003Csummary\u003E Two. \u003C/summary\u003E\n        Two = 2,\n        /// \u003Csummary\u003E Four. \u003C/summary\u003E\n        Four = 4\n    }\n}\n"
          }
        },
        {
          "name": "IntFixedEnum.cs",
          "typeDeclaration": {
            "name": "IntFixedEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E int fixed enum. \u003C/summary\u003E\n    public enum IntFixedEnum\n    {\n        /// \u003Csummary\u003E One. \u003C/summary\u003E\n        One = 1,\n        /// \u003Csummary\u003E Two. \u003C/summary\u003E\n        Two = 2,\n        /// \u003Csummary\u003E Four. \u003C/summary\u003E\n        Four = 4\n    }\n}\n"
          }
        },
        {
          "name": "Thing.cs",
          "typeDeclaration": {
            "name": "Thing",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E A model with a few properties of literal types. \u003C/summary\u003E\n    public partial class Thing\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E _additionalBinaryDataProperties;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.Thing\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E, \u003Cparamref name=\u0022requiredUnion\u0022/\u003E or \u003Cparamref name=\u0022requiredBadDescription\u0022/\u003E is null. \u003C/exception\u003E\n        public Thing(string name, global::System.BinaryData requiredUnion, string requiredBadDescription, global::System.Collections.Generic.IEnumerable\u003Cint\u003E requiredNullableList)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(name, nameof(name));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredUnion, nameof(requiredUnion));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredBadDescription, nameof(requiredBadDescription));\n\n            Name = name;\n            RequiredUnion = requiredUnion;\n            RequiredBadDescription = requiredBadDescription;\n            OptionalNullableList = new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cint\u003E();\n            RequiredNullableList = requiredNullableList?.ToList();\n        }\n\n        internal Thing(string name, global::System.BinaryData requiredUnion, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString requiredLiteralString, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt requiredLiteralInt, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat requiredLiteralFloat, bool requiredLiteralBool, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString? optionalLiteralString, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt? optionalLiteralInt, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat? optionalLiteralFloat, bool? optionalLiteralBool, string requiredBadDescription, global::System.Collections.Generic.IList\u003Cint\u003E optionalNullableList, global::System.Collections.Generic.IList\u003Cint\u003E requiredNullableList, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E additionalBinaryDataProperties)\n        {\n            Name = name;\n            RequiredUnion = requiredUnion;\n            RequiredLiteralString = requiredLiteralString;\n            RequiredLiteralInt = requiredLiteralInt;\n            RequiredLiteralFloat = requiredLiteralFloat;\n            RequiredLiteralBool = requiredLiteralBool;\n            OptionalLiteralString = optionalLiteralString;\n            OptionalLiteralInt = optionalLiteralInt;\n            OptionalLiteralFloat = optionalLiteralFloat;\n            OptionalLiteralBool = optionalLiteralBool;\n            RequiredBadDescription = requiredBadDescription;\n            OptionalNullableList = optionalNullableList;\n            RequiredNullableList = requiredNullableList;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E name of the Thing. \u003C/summary\u003E\n        public string Name { get; set; }\n\n        /// \u003Csummary\u003E\n        /// required Union\n        /// \u003Cpara\u003E To assign an object to this property use \u003Csee cref=\u0022global::System.BinaryData.FromObjectAsJson{T}(T, global::System.Text.Json.JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022global::System.BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// \u003Cremarks\u003E\n        /// Supported types:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E \u003Csee cref=\u0022string\u0022/\u003E. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E \u003Csee cref=\u0022global::System.Collections.Generic.IList{T}\u0022/\u003E where \u003Cc\u003ET\u003C/c\u003E is of type \u003Csee cref=\u0022string\u0022/\u003E. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E \u003Csee cref=\u0022int\u0022/\u003E. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/remarks\u003E\n        /// \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.BinaryData RequiredUnion { get; set; }\n\n        /// \u003Csummary\u003E required literal string. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString RequiredLiteralString { get; } = \u0022accept\u0022;\n\n        /// \u003Csummary\u003E required literal int. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt RequiredLiteralInt { get; } = 123;\n\n        /// \u003Csummary\u003E required literal float. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat RequiredLiteralFloat { get; } = 1.23F;\n\n        /// \u003Csummary\u003E required literal bool. \u003C/summary\u003E\n        public bool RequiredLiteralBool { get; } = false;\n\n        /// \u003Csummary\u003E optional literal string. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString? OptionalLiteralString { get; set; }\n\n        /// \u003Csummary\u003E optional literal int. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt? OptionalLiteralInt { get; set; }\n\n        /// \u003Csummary\u003E optional literal float. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat? OptionalLiteralFloat { get; set; }\n\n        /// \u003Csummary\u003E optional literal bool. \u003C/summary\u003E\n        public bool? OptionalLiteralBool { get; set; }\n\n        /// \u003Csummary\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/summary\u003E\n        public string RequiredBadDescription { get; set; }\n\n        /// \u003Csummary\u003E optional nullable collection. \u003C/summary\u003E\n        public global::System.Collections.Generic.IList\u003Cint\u003E OptionalNullableList { get; set; }\n\n        /// \u003Csummary\u003E required nullable collection. \u003C/summary\u003E\n        public global::System.Collections.Generic.IList\u003Cint\u003E RequiredNullableList { get; set; }\n    }\n}\n"
          }
        },
        {
          "name": "RoundTripModel.cs",
          "typeDeclaration": {
            "name": "RoundTripModel",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E this is a roundtrip model. \u003C/summary\u003E\n    public partial class RoundTripModel\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E _additionalBinaryDataProperties;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.RoundTripModel\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredString\u0022\u003E Required string, illustrating a reference type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredInt\u0022\u003E Required int, illustrating a value type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredCollection\u0022\u003E Required collection of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredDictionary\u0022\u003E Required dictionary of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredModel\u0022\u003E Required model. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnknown\u0022\u003E required unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredRecordUnknown\u0022\u003E required record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022modelWithRequiredNullable\u0022\u003E this is a model with required nullable properties. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBytes\u0022\u003E Required bytes. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022requiredString\u0022/\u003E, \u003Cparamref name=\u0022requiredCollection\u0022/\u003E, \u003Cparamref name=\u0022requiredDictionary\u0022/\u003E, \u003Cparamref name=\u0022requiredModel\u0022/\u003E, \u003Cparamref name=\u0022requiredUnknown\u0022/\u003E, \u003Cparamref name=\u0022requiredRecordUnknown\u0022/\u003E, \u003Cparamref name=\u0022modelWithRequiredNullable\u0022/\u003E or \u003Cparamref name=\u0022requiredBytes\u0022/\u003E is null. \u003C/exception\u003E\n        public RoundTripModel(string requiredString, int requiredInt, global::System.Collections.Generic.IEnumerable\u003Cglobal::UnbrandedTypeSpec.Models.StringFixedEnum\u003E requiredCollection, global::System.Collections.Generic.IDictionary\u003Cstring, global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u003E requiredDictionary, global::UnbrandedTypeSpec.Models.Thing requiredModel, global::System.BinaryData requiredUnknown, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E requiredRecordUnknown, global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties modelWithRequiredNullable, global::System.BinaryData requiredBytes)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredString, nameof(requiredString));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredCollection, nameof(requiredCollection));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredDictionary, nameof(requiredDictionary));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredModel, nameof(requiredModel));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredUnknown, nameof(requiredUnknown));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredRecordUnknown, nameof(requiredRecordUnknown));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(modelWithRequiredNullable, nameof(modelWithRequiredNullable));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredBytes, nameof(requiredBytes));\n\n            RequiredString = requiredString;\n            RequiredInt = requiredInt;\n            RequiredCollection = requiredCollection.ToList();\n            RequiredDictionary = requiredDictionary;\n            RequiredModel = requiredModel;\n            IntExtensibleEnumCollection = new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.IntExtensibleEnum\u003E();\n            FloatExtensibleEnumCollection = new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u003E();\n            FloatFixedEnumCollection = new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.FloatFixedEnum\u003E();\n            IntFixedEnumCollection = new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.IntFixedEnum\u003E();\n            RequiredUnknown = requiredUnknown;\n            RequiredRecordUnknown = requiredRecordUnknown;\n            OptionalRecordUnknown = new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::System.BinaryData\u003E();\n            ReadOnlyRequiredRecordUnknown = new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::System.BinaryData\u003E();\n            ReadOnlyOptionalRecordUnknown = new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::System.BinaryData\u003E();\n            ModelWithRequiredNullable = modelWithRequiredNullable;\n            RequiredBytes = requiredBytes;\n        }\n\n        internal RoundTripModel(string requiredString, int requiredInt, global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.StringFixedEnum\u003E requiredCollection, global::System.Collections.Generic.IDictionary\u003Cstring, global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u003E requiredDictionary, global::UnbrandedTypeSpec.Models.Thing requiredModel, global::UnbrandedTypeSpec.Models.IntExtensibleEnum? intExtensibleEnum, global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.IntExtensibleEnum\u003E intExtensibleEnumCollection, global::UnbrandedTypeSpec.Models.FloatExtensibleEnum? floatExtensibleEnum, global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue? floatExtensibleEnumWithIntValue, global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u003E floatExtensibleEnumCollection, global::UnbrandedTypeSpec.Models.FloatFixedEnum? floatFixedEnum, global::UnbrandedTypeSpec.Models.FloatFixedEnumWithIntValue? floatFixedEnumWithIntValue, global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.FloatFixedEnum\u003E floatFixedEnumCollection, global::UnbrandedTypeSpec.Models.IntFixedEnum? intFixedEnum, global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.IntFixedEnum\u003E intFixedEnumCollection, global::UnbrandedTypeSpec.Models.StringFixedEnum? stringFixedEnum, global::System.BinaryData requiredUnknown, global::System.BinaryData optionalUnknown, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E requiredRecordUnknown, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E optionalRecordUnknown, global::System.Collections.Generic.IReadOnlyDictionary\u003Cstring, global::System.BinaryData\u003E readOnlyRequiredRecordUnknown, global::System.Collections.Generic.IReadOnlyDictionary\u003Cstring, global::System.BinaryData\u003E readOnlyOptionalRecordUnknown, global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties modelWithRequiredNullable, global::System.BinaryData requiredBytes, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E additionalBinaryDataProperties)\n        {\n            RequiredString = requiredString;\n            RequiredInt = requiredInt;\n            RequiredCollection = requiredCollection;\n            RequiredDictionary = requiredDictionary;\n            RequiredModel = requiredModel;\n            IntExtensibleEnum = intExtensibleEnum;\n            IntExtensibleEnumCollection = intExtensibleEnumCollection;\n            FloatExtensibleEnum = floatExtensibleEnum;\n            FloatExtensibleEnumWithIntValue = floatExtensibleEnumWithIntValue;\n            FloatExtensibleEnumCollection = floatExtensibleEnumCollection;\n            FloatFixedEnum = floatFixedEnum;\n            FloatFixedEnumWithIntValue = floatFixedEnumWithIntValue;\n            FloatFixedEnumCollection = floatFixedEnumCollection;\n            IntFixedEnum = intFixedEnum;\n            IntFixedEnumCollection = intFixedEnumCollection;\n            StringFixedEnum = stringFixedEnum;\n            RequiredUnknown = requiredUnknown;\n            OptionalUnknown = optionalUnknown;\n            RequiredRecordUnknown = requiredRecordUnknown;\n            OptionalRecordUnknown = optionalRecordUnknown;\n            ReadOnlyRequiredRecordUnknown = readOnlyRequiredRecordUnknown;\n            ReadOnlyOptionalRecordUnknown = readOnlyOptionalRecordUnknown;\n            ModelWithRequiredNullable = modelWithRequiredNullable;\n            RequiredBytes = requiredBytes;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E Required string, illustrating a reference type property. \u003C/summary\u003E\n        public string RequiredString { get; set; }\n\n        /// \u003Csummary\u003E Required int, illustrating a value type property. \u003C/summary\u003E\n        public int RequiredInt { get; set; }\n\n        /// \u003Csummary\u003E Required collection of enums. \u003C/summary\u003E\n        public global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.StringFixedEnum\u003E RequiredCollection { get; }\n\n        /// \u003Csummary\u003E Required dictionary of enums. \u003C/summary\u003E\n        public global::System.Collections.Generic.IDictionary\u003Cstring, global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u003E RequiredDictionary { get; }\n\n        /// \u003Csummary\u003E Required model. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.Thing RequiredModel { get; set; }\n\n        /// \u003Csummary\u003E this is an int based extensible enum. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.IntExtensibleEnum? IntExtensibleEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of int based extensible enum. \u003C/summary\u003E\n        public global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.IntExtensibleEnum\u003E IntExtensibleEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a float based extensible enum. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.FloatExtensibleEnum? FloatExtensibleEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a float based extensible enum. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue? FloatExtensibleEnumWithIntValue { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of float based extensible enum. \u003C/summary\u003E\n        public global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u003E FloatExtensibleEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a float based fixed enum. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.FloatFixedEnum? FloatFixedEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a float based fixed enum. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.FloatFixedEnumWithIntValue? FloatFixedEnumWithIntValue { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of float based fixed enum. \u003C/summary\u003E\n        public global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.FloatFixedEnum\u003E FloatFixedEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a int based fixed enum. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.IntFixedEnum? IntFixedEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of int based fixed enum. \u003C/summary\u003E\n        public global::System.Collections.Generic.IList\u003Cglobal::UnbrandedTypeSpec.Models.IntFixedEnum\u003E IntFixedEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a string based fixed enum. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.StringFixedEnum? StringFixedEnum { get; set; }\n\n        /// \u003Csummary\u003E\n        /// required unknown\n        /// \u003Cpara\u003E To assign an object to this property use \u003Csee cref=\u0022global::System.BinaryData.FromObjectAsJson{T}(T, global::System.Text.Json.JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022global::System.BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.BinaryData RequiredUnknown { get; set; }\n\n        /// \u003Csummary\u003E\n        /// optional unknown\n        /// \u003Cpara\u003E To assign an object to this property use \u003Csee cref=\u0022global::System.BinaryData.FromObjectAsJson{T}(T, global::System.Text.Json.JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022global::System.BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.BinaryData OptionalUnknown { get; set; }\n\n        /// \u003Csummary\u003E\n        /// required record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022global::System.BinaryData.FromObjectAsJson{T}(T, global::System.Text.Json.JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022global::System.BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E RequiredRecordUnknown { get; }\n\n        /// \u003Csummary\u003E\n        /// optional record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022global::System.BinaryData.FromObjectAsJson{T}(T, global::System.Text.Json.JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022global::System.BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E OptionalRecordUnknown { get; }\n\n        /// \u003Csummary\u003E\n        /// required readonly record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022global::System.BinaryData.FromObjectAsJson{T}(T, global::System.Text.Json.JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022global::System.BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.Collections.Generic.IReadOnlyDictionary\u003Cstring, global::System.BinaryData\u003E ReadOnlyRequiredRecordUnknown { get; }\n\n        /// \u003Csummary\u003E\n        /// optional readonly record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022global::System.BinaryData.FromObjectAsJson{T}(T, global::System.Text.Json.JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022global::System.BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.Collections.Generic.IReadOnlyDictionary\u003Cstring, global::System.BinaryData\u003E ReadOnlyOptionalRecordUnknown { get; }\n\n        /// \u003Csummary\u003E this is a model with required nullable properties. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties ModelWithRequiredNullable { get; set; }\n\n        /// \u003Csummary\u003E\n        /// Required bytes\n        /// \u003Cpara\u003E\n        /// To assign a byte[] to this property use \u003Csee cref=\u0022global::System.BinaryData.FromBytes(byte[])\u0022/\u003E.\n        /// The byte[] will be serialized to a Base64 encoded string.\n        /// \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromBytes(new byte[] { 1, 2, 3 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022AQID\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public global::System.BinaryData RequiredBytes { get; set; }\n    }\n}\n"
          }
        },
        {
          "name": "ModelWithRequiredNullableProperties.cs",
          "typeDeclaration": {
            "name": "ModelWithRequiredNullableProperties",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E A model with a few required nullable properties. \u003C/summary\u003E\n    public partial class ModelWithRequiredNullableProperties\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E _additionalBinaryDataProperties;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredNullablePrimitive\u0022\u003E required nullable primitive type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredExtensibleEnum\u0022\u003E required nullable extensible enum type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredFixedEnum\u0022\u003E required nullable fixed enum type. \u003C/param\u003E\n        public ModelWithRequiredNullableProperties(int? requiredNullablePrimitive, global::UnbrandedTypeSpec.Models.StringExtensibleEnum? requiredExtensibleEnum, global::UnbrandedTypeSpec.Models.StringFixedEnum? requiredFixedEnum)\n        {\n            RequiredNullablePrimitive = requiredNullablePrimitive;\n            RequiredExtensibleEnum = requiredExtensibleEnum;\n            RequiredFixedEnum = requiredFixedEnum;\n        }\n\n        internal ModelWithRequiredNullableProperties(int? requiredNullablePrimitive, global::UnbrandedTypeSpec.Models.StringExtensibleEnum? requiredExtensibleEnum, global::UnbrandedTypeSpec.Models.StringFixedEnum? requiredFixedEnum, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E additionalBinaryDataProperties)\n        {\n            RequiredNullablePrimitive = requiredNullablePrimitive;\n            RequiredExtensibleEnum = requiredExtensibleEnum;\n            RequiredFixedEnum = requiredFixedEnum;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E required nullable primitive type. \u003C/summary\u003E\n        public int? RequiredNullablePrimitive { get; set; }\n\n        /// \u003Csummary\u003E required nullable extensible enum type. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.StringExtensibleEnum? RequiredExtensibleEnum { get; set; }\n\n        /// \u003Csummary\u003E required nullable fixed enum type. \u003C/summary\u003E\n        public global::UnbrandedTypeSpec.Models.StringFixedEnum? RequiredFixedEnum { get; set; }\n    }\n}\n"
          }
        },
        {
          "name": "Friend.cs",
          "typeDeclaration": {
            "name": "Friend",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E this is not a friendly model but with a friendly name. \u003C/summary\u003E\n    public partial class Friend\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E _additionalBinaryDataProperties;\n\n        internal Friend(string name)\n        {\n            Name = name;\n        }\n\n        internal Friend(string name, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E additionalBinaryDataProperties)\n        {\n            Name = name;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E name of the NotFriend. \u003C/summary\u003E\n        public string Name { get; }\n    }\n}\n"
          }
        },
        {
          "name": "ProjectedModel.cs",
          "typeDeclaration": {
            "name": "ProjectedModel",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E this is a model with a projected name. \u003C/summary\u003E\n    public partial class ProjectedModel\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E _additionalBinaryDataProperties;\n\n        internal ProjectedModel(string name)\n        {\n            Name = name;\n        }\n\n        internal ProjectedModel(string name, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E additionalBinaryDataProperties)\n        {\n            Name = name;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E name of the ModelWithProjectedName. \u003C/summary\u003E\n        public string Name { get; }\n    }\n}\n"
          }
        },
        {
          "name": "ReturnsAnonymousModelResponse.cs",
          "typeDeclaration": {
            "name": "ReturnsAnonymousModelResponse",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The ReturnsAnonymousModelResponse. \u003C/summary\u003E\n    public partial class ReturnsAnonymousModelResponse\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E _additionalBinaryDataProperties;\n\n        internal ReturnsAnonymousModelResponse()\n        {\n        }\n\n        internal ReturnsAnonymousModelResponse(global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E additionalBinaryDataProperties)\n        {\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n    }\n}\n"
          }
        }
      ]
    },
    {
      "name": "src\\Generated\\Internal",
      "files": [
        {
          "name": "ChangeTrackingList.cs",
          "typeDeclaration": {
            "name": "ChangeTrackingList",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ChangeTrackingList\u003CT\u003E : global::System.Collections.Generic.IList\u003CT\u003E, global::System.Collections.Generic.IReadOnlyList\u003CT\u003E\n    {\n        private global::System.Collections.Generic.IList\u003CT\u003E _innerList;\n\n        public ChangeTrackingList()\n        {\n        }\n\n        public ChangeTrackingList(global::System.Collections.Generic.IList\u003CT\u003E innerList)\n        {\n            if ((innerList != null))\n            {\n                _innerList = innerList;\n            }\n        }\n\n        public ChangeTrackingList(global::System.Collections.Generic.IReadOnlyList\u003CT\u003E innerList)\n        {\n            if ((innerList != null))\n            {\n                _innerList = innerList.ToList();\n            }\n        }\n\n        public bool IsUndefined =\u003E (_innerList == null);\n\n        public int Count =\u003E this.IsUndefined ? 0 : this.EnsureList().Count;\n\n        public bool IsReadOnly =\u003E this.IsUndefined ? false : this.EnsureList().IsReadOnly;\n\n        public T this[int index]\n        {\n            get\n            {\n                if (this.IsUndefined)\n                {\n                    throw new global::System.ArgumentOutOfRangeException(nameof(index));\n                }\n                return this.EnsureList()[index];\n            }\n            set\n            {\n                if (this.IsUndefined)\n                {\n                    throw new global::System.ArgumentOutOfRangeException(nameof(index));\n                }\n                this.EnsureList()[index] = value;\n            }\n        }\n\n        public void Reset()\n        {\n            _innerList = null;\n        }\n\n        public global::System.Collections.Generic.IEnumerator\u003CT\u003E GetEnumerator()\n        {\n            if (this.IsUndefined)\n            {\n                global::System.Collections.Generic.IEnumerator\u003CT\u003E enumerateEmpty()\n                {\n                    yield break;\n                }\n                return enumerateEmpty();\n            }\n            return this.EnsureList().GetEnumerator();\n        }\n\n        global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()\n        {\n            return this.GetEnumerator();\n        }\n\n        public void Add(T item)\n        {\n            this.EnsureList().Add(item);\n        }\n\n        public void Clear()\n        {\n            this.EnsureList().Clear();\n        }\n\n        public bool Contains(T item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureList().Contains(item);\n        }\n\n        public void CopyTo(T[] array, int arrayIndex)\n        {\n            if (this.IsUndefined)\n            {\n                return;\n            }\n            this.EnsureList().CopyTo(array, arrayIndex);\n        }\n\n        public bool Remove(T item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureList().Remove(item);\n        }\n\n        public int IndexOf(T item)\n        {\n            if (this.IsUndefined)\n            {\n                return -1;\n            }\n            return this.EnsureList().IndexOf(item);\n        }\n\n        public void Insert(int index, T item)\n        {\n            this.EnsureList().Insert(index, item);\n        }\n\n        public void RemoveAt(int index)\n        {\n            if (this.IsUndefined)\n            {\n                throw new global::System.ArgumentOutOfRangeException(nameof(index));\n            }\n            this.EnsureList().RemoveAt(index);\n        }\n\n        public global::System.Collections.Generic.IList\u003CT\u003E EnsureList()\n        {\n            return (_innerList ??= new global::System.Collections.Generic.List\u003CT\u003E());\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ChangeTrackingDictionary.cs",
          "typeDeclaration": {
            "name": "ChangeTrackingDictionary",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ChangeTrackingDictionary\u003CTKey, TValue\u003E : global::System.Collections.Generic.IDictionary\u003CTKey, TValue\u003E, global::System.Collections.Generic.IReadOnlyDictionary\u003CTKey, TValue\u003E\n        where TKey : notnull\n    {\n        private global::System.Collections.Generic.IDictionary\u003CTKey, TValue\u003E _innerDictionary;\n\n        public ChangeTrackingDictionary()\n        {\n        }\n\n        public ChangeTrackingDictionary(global::System.Collections.Generic.IDictionary\u003CTKey, TValue\u003E dictionary)\n        {\n            if ((dictionary == null))\n            {\n                return;\n            }\n            _innerDictionary = new global::System.Collections.Generic.Dictionary\u003CTKey, TValue\u003E(dictionary);\n        }\n\n        public ChangeTrackingDictionary(global::System.Collections.Generic.IReadOnlyDictionary\u003CTKey, TValue\u003E dictionary)\n        {\n            if ((dictionary == null))\n            {\n                return;\n            }\n            _innerDictionary = new global::System.Collections.Generic.Dictionary\u003CTKey, TValue\u003E();\n            foreach (var pair in dictionary)\n            {\n                _innerDictionary.Add(pair);\n            }\n        }\n\n        public bool IsUndefined =\u003E (_innerDictionary == null);\n\n        public int Count =\u003E this.IsUndefined ? 0 : this.EnsureDictionary().Count;\n\n        public bool IsReadOnly =\u003E this.IsUndefined ? false : this.EnsureDictionary().IsReadOnly;\n\n        public global::System.Collections.Generic.ICollection\u003CTKey\u003E Keys =\u003E this.IsUndefined ? global::System.Array.Empty\u003CTKey\u003E() : this.EnsureDictionary().Keys;\n\n        public global::System.Collections.Generic.ICollection\u003CTValue\u003E Values =\u003E this.IsUndefined ? global::System.Array.Empty\u003CTValue\u003E() : this.EnsureDictionary().Values;\n\n        public TValue this[TKey key]\n        {\n            get\n            {\n                if (this.IsUndefined)\n                {\n                    throw new global::System.Collections.Generic.KeyNotFoundException(nameof(key));\n                }\n                return this.EnsureDictionary()[key];\n            }\n            set\n            {\n                this.EnsureDictionary()[key] = value;\n            }\n        }\n\n        global::System.Collections.Generic.IEnumerable\u003CTKey\u003E global::System.Collections.Generic.IReadOnlyDictionary\u003CTKey, TValue\u003E.Keys =\u003E this.Keys;\n\n        global::System.Collections.Generic.IEnumerable\u003CTValue\u003E global::System.Collections.Generic.IReadOnlyDictionary\u003CTKey, TValue\u003E.Values =\u003E this.Values;\n\n        public global::System.Collections.Generic.IEnumerator\u003Cglobal::System.Collections.Generic.KeyValuePair\u003CTKey, TValue\u003E\u003E GetEnumerator()\n        {\n            if (this.IsUndefined)\n            {\n                global::System.Collections.Generic.IEnumerator\u003Cglobal::System.Collections.Generic.KeyValuePair\u003CTKey, TValue\u003E\u003E enumerateEmpty()\n                {\n                    yield break;\n                }\n                return enumerateEmpty();\n            }\n            return this.EnsureDictionary().GetEnumerator();\n        }\n\n        global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()\n        {\n            return this.GetEnumerator();\n        }\n\n        public void Add(global::System.Collections.Generic.KeyValuePair\u003CTKey, TValue\u003E item)\n        {\n            this.EnsureDictionary().Add(item);\n        }\n\n        public void Clear()\n        {\n            this.EnsureDictionary().Clear();\n        }\n\n        public bool Contains(global::System.Collections.Generic.KeyValuePair\u003CTKey, TValue\u003E item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().Contains(item);\n        }\n\n        public void CopyTo(global::System.Collections.Generic.KeyValuePair\u003CTKey, TValue\u003E[] array, int index)\n        {\n            if (this.IsUndefined)\n            {\n                return;\n            }\n            this.EnsureDictionary().CopyTo(array, index);\n        }\n\n        public bool Remove(global::System.Collections.Generic.KeyValuePair\u003CTKey, TValue\u003E item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().Remove(item);\n        }\n\n        public void Add(TKey key, TValue value)\n        {\n            this.EnsureDictionary().Add(key, value);\n        }\n\n        public bool ContainsKey(TKey key)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().ContainsKey(key);\n        }\n\n        public bool Remove(TKey key)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().Remove(key);\n        }\n\n        public bool TryGetValue(TKey key, out TValue value)\n        {\n            if (this.IsUndefined)\n            {\n                value = default;\n                return false;\n            }\n            return this.EnsureDictionary().TryGetValue(key, out value);\n        }\n\n        public global::System.Collections.Generic.IDictionary\u003CTKey, TValue\u003E EnsureDictionary()\n        {\n            return (_innerDictionary ??= new global::System.Collections.Generic.Dictionary\u003CTKey, TValue\u003E());\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Argument.cs",
          "typeDeclaration": {
            "name": "Argument",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class Argument\n    {\n        public static void AssertNotNull\u003CT\u003E(T value, string name)\n        {\n            if ((value is null))\n            {\n                throw new global::System.ArgumentNullException(name);\n            }\n        }\n\n        public static void AssertNotNull\u003CT\u003E(T? value, string name)\n            where T : struct \n        {\n            if (!value.HasValue)\n            {\n                throw new global::System.ArgumentNullException(name);\n            }\n        }\n\n        public static void AssertNotNullOrEmpty\u003CT\u003E(global::System.Collections.Generic.IEnumerable\u003CT\u003E value, string name)\n        {\n            if ((value is null))\n            {\n                throw new global::System.ArgumentNullException(name);\n            }\n            if (((value is global::System.Collections.Generic.ICollection\u003CT\u003E collectionOfT) \u0026\u0026 (collectionOfT.Count == 0)))\n            {\n                throw new global::System.ArgumentException(\u0022Value cannot be an empty collection.\u0022, name);\n            }\n            if (((value is global::System.Collections.ICollection collection) \u0026\u0026 (collection.Count == 0)))\n            {\n                throw new global::System.ArgumentException(\u0022Value cannot be an empty collection.\u0022, name);\n            }\n            using global::System.Collections.Generic.IEnumerator\u003CT\u003E e = value.GetEnumerator();\n            if (!e.MoveNext())\n            {\n                throw new global::System.ArgumentException(\u0022Value cannot be an empty collection.\u0022, name);\n            }\n        }\n\n        public static void AssertNotNullOrEmpty(string value, string name)\n        {\n            if ((value is null))\n            {\n                throw new global::System.ArgumentNullException(name);\n            }\n            if ((value.Length == 0))\n            {\n                throw new global::System.ArgumentException(\u0022Value cannot be an empty string.\u0022, name);\n            }\n        }\n\n        public static void AssertNotNullOrWhiteSpace(string value, string name)\n        {\n            if ((value is null))\n            {\n                throw new global::System.ArgumentNullException(name);\n            }\n            if (string.IsNullOrWhiteSpace(value))\n            {\n                throw new global::System.ArgumentException(\u0022Value cannot be empty or contain only white-space characters.\u0022, name);\n            }\n        }\n\n        public static void AssertNotDefault\u003CT\u003E(ref T value, string name)\n            where T : struct, global::System.IEquatable\u003CT\u003E \n        {\n            if (value.Equals(default))\n            {\n                throw new global::System.ArgumentException(\u0022Value cannot be empty.\u0022, name);\n            }\n        }\n\n        public static void AssertInRange\u003CT\u003E(T value, T minimum, T maximum, string name)\n            where T : notnull, global::System.IComparable\u003CT\u003E \n        {\n            if ((minimum.CompareTo(value) \u003E 0))\n            {\n                throw new global::System.ArgumentOutOfRangeException(name, \u0022Value is less than the minimum allowed.\u0022);\n            }\n            if ((maximum.CompareTo(value) \u003C 0))\n            {\n                throw new global::System.ArgumentOutOfRangeException(name, \u0022Value is greater than the maximum allowed.\u0022);\n            }\n        }\n\n        public static void AssertEnumDefined(global::System.Type enumType, object value, string name)\n        {\n            if (!global::System.Enum.IsDefined(enumType, value))\n            {\n                throw new global::System.ArgumentException($\u0022Value not defined for {enumType.FullName}.\u0022, name);\n            }\n        }\n\n        public static T CheckNotNull\u003CT\u003E(T value, string name)\n            where T : class \n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(value, name);\n            return value;\n        }\n\n        public static string CheckNotNullOrEmpty(string value, string name)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNullOrEmpty(value, name);\n            return value;\n        }\n\n        public static void AssertNull\u003CT\u003E(T value, string name, string message = ((string)null))\n        {\n            if ((value != null))\n            {\n                throw new global::System.ArgumentException((message ?? \u0022Value must be null.\u0022), name);\n            }\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Optional.cs",
          "typeDeclaration": {
            "name": "Optional",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class Optional\n    {\n        public static bool IsCollectionDefined\u003CT\u003E(global::System.Collections.Generic.IEnumerable\u003CT\u003E collection)\n        {\n            return !((collection is global::UnbrandedTypeSpec.ChangeTrackingList\u003CT\u003E changeTrackingList) \u0026\u0026 changeTrackingList.IsUndefined);\n        }\n\n        public static bool IsCollectionDefined\u003CTKey, TValue\u003E(global::System.Collections.Generic.IDictionary\u003CTKey, TValue\u003E collection)\n        {\n            return !((collection is global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003CTKey, TValue\u003E changeTrackingDictionary) \u0026\u0026 changeTrackingDictionary.IsUndefined);\n        }\n\n        public static bool IsCollectionDefined\u003CTKey, TValue\u003E(global::System.Collections.Generic.IReadOnlyDictionary\u003CTKey, TValue\u003E collection)\n        {\n            return !((collection is global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003CTKey, TValue\u003E changeTrackingDictionary) \u0026\u0026 changeTrackingDictionary.IsUndefined);\n        }\n\n        public static bool IsDefined\u003CT\u003E(T? value)\n            where T : struct \n        {\n            return value.HasValue;\n        }\n\n        public static bool IsDefined(object value)\n        {\n            return (value != null);\n        }\n\n        public static bool IsDefined(string value)\n        {\n            return (value != null);\n        }\n\n        public static bool IsDefined(global::System.Text.Json.JsonElement value)\n        {\n            return (value.ValueKind != global::System.Text.Json.JsonValueKind.Undefined);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ModelSerializationExtensions.cs",
          "typeDeclaration": {
            "name": "ModelSerializationExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Text.Json;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class ModelSerializationExtensions\n    {\n        internal static readonly global::System.ClientModel.Primitives.ModelReaderWriterOptions WireOptions = new global::System.ClientModel.Primitives.ModelReaderWriterOptions(\u0022W\u0022);\n\n        public static object GetObject(this global::System.Text.Json.JsonElement element)\n        {\n            switch (element.ValueKind)\n            {\n                case global::System.Text.Json.JsonValueKind.String:\n                    return element.GetString();\n                case global::System.Text.Json.JsonValueKind.Number:\n                    if (element.TryGetInt32(out int intValue))\n                    {\n                        return intValue;\n                    }\n                    if (element.TryGetInt64(out long longValue))\n                    {\n                        return longValue;\n                    }\n                    return element.GetDouble();\n                case global::System.Text.Json.JsonValueKind.True:\n                    return true;\n                case global::System.Text.Json.JsonValueKind.False:\n                    return false;\n                case global::System.Text.Json.JsonValueKind.Undefined:\n                case global::System.Text.Json.JsonValueKind.Null:\n                    return null;\n                case global::System.Text.Json.JsonValueKind.Object:\n                    global::System.Collections.Generic.Dictionary\u003Cstring, object\u003E dictionary = new global::System.Collections.Generic.Dictionary\u003Cstring, object\u003E();\n                    foreach (var jsonProperty in element.EnumerateObject())\n                    {\n                        dictionary.Add(jsonProperty.Name, jsonProperty.Value.GetObject());\n                    }\n                    return dictionary;\n                case global::System.Text.Json.JsonValueKind.Array:\n                    global::System.Collections.Generic.List\u003Cobject\u003E list = new global::System.Collections.Generic.List\u003Cobject\u003E();\n                    foreach (var item in element.EnumerateArray())\n                    {\n                        list.Add(item.GetObject());\n                    }\n                    return list.ToArray();\n                default:\n                    throw new global::System.NotSupportedException($\u0022Not supported value kind {element.ValueKind}\u0022);\n            }\n        }\n\n        public static global::System.Byte[] GetBytesFromBase64(this global::System.Text.Json.JsonElement element, string format)\n        {\n            if ((element.ValueKind == global::System.Text.Json.JsonValueKind.Null))\n            {\n                return null;\n            }\n\n            return format switch\n            {\n                \u0022U\u0022 =\u003E global::UnbrandedTypeSpec.TypeFormatters.FromBase64UrlString(element.GetRequiredString()),\n                \u0022D\u0022 =\u003E element.GetBytesFromBase64(),\n                _ =\u003E throw new global::System.ArgumentException($\u0022Format is not supported: \u0027{format}\u0027\u0022, nameof(format))\n            };\n        }\n\n        public static global::System.DateTimeOffset GetDateTimeOffset(this global::System.Text.Json.JsonElement element, string format) =\u003E format switch\n        {\n            \u0022U\u0022 when (element.ValueKind == global::System.Text.Json.JsonValueKind.Number) =\u003E global::System.DateTimeOffset.FromUnixTimeSeconds(element.GetInt64()),\n            _ =\u003E global::UnbrandedTypeSpec.TypeFormatters.ParseDateTimeOffset(element.GetString(), format)\n        };\n\n        public static global::System.TimeSpan GetTimeSpan(this global::System.Text.Json.JsonElement element, string format) =\u003E global::UnbrandedTypeSpec.TypeFormatters.ParseTimeSpan(element.GetString(), format);\n\n        public static char GetChar(this global::System.Text.Json.JsonElement element)\n        {\n            if ((element.ValueKind == global::System.Text.Json.JsonValueKind.String))\n            {\n                string text = element.GetString();\n                if (((text == null) || (text.Length != 1)))\n                {\n                    throw new global::System.NotSupportedException($\u0022Cannot convert \\\u0022{text}\\\u0022 to a char\u0022);\n                }\n                return text[0];\n            }\n            else\n            {\n                throw new global::System.NotSupportedException($\u0022Cannot convert {element.ValueKind} to a char\u0022);\n            }\n        }\n\n        [global::System.Diagnostics.ConditionalAttribute(\u0022DEBUG\u0022)]\n        public static void ThrowNonNullablePropertyIsNull(this global::System.Text.Json.JsonProperty @property)\n        {\n            throw new global::System.Text.Json.JsonException($\u0022A property \u0027{@property.Name}\u0027 defined as non-nullable but received as null from the service. This exception only happens in DEBUG builds of the library and would be ignored in the release build\u0022);\n        }\n\n        public static string GetRequiredString(this global::System.Text.Json.JsonElement element)\n        {\n            string value = element.GetString();\n            if ((value == null))\n            {\n                throw new global::System.InvalidOperationException($\u0022The requested operation requires an element of type \u0027String\u0027, but the target element has type \u0027{element.ValueKind}\u0027.\u0022);\n            }\n            return value;\n        }\n\n        public static void WriteStringValue(this global::System.Text.Json.Utf8JsonWriter writer, global::System.DateTimeOffset value, string format)\n        {\n            writer.WriteStringValue(global::UnbrandedTypeSpec.TypeFormatters.ToString(value, format));\n        }\n\n        public static void WriteStringValue(this global::System.Text.Json.Utf8JsonWriter writer, global::System.DateTime value, string format)\n        {\n            writer.WriteStringValue(global::UnbrandedTypeSpec.TypeFormatters.ToString(value, format));\n        }\n\n        public static void WriteStringValue(this global::System.Text.Json.Utf8JsonWriter writer, global::System.TimeSpan value, string format)\n        {\n            writer.WriteStringValue(global::UnbrandedTypeSpec.TypeFormatters.ToString(value, format));\n        }\n\n        public static void WriteStringValue(this global::System.Text.Json.Utf8JsonWriter writer, char value)\n        {\n            writer.WriteStringValue(value.ToString(global::System.Globalization.CultureInfo.InvariantCulture));\n        }\n\n        public static void WriteBase64StringValue(this global::System.Text.Json.Utf8JsonWriter writer, global::System.Byte[] value, string format)\n        {\n            if ((value == null))\n            {\n                writer.WriteNullValue();\n                return;\n            }\n            switch (format)\n            {\n                case \u0022U\u0022:\n                    writer.WriteStringValue(global::UnbrandedTypeSpec.TypeFormatters.ToBase64UrlString(value));\n                    break;\n                case \u0022D\u0022:\n                    writer.WriteBase64StringValue(value);\n                    break;\n                default:\n                    throw new global::System.ArgumentException($\u0022Format is not supported: \u0027{format}\u0027\u0022, nameof(format));\n            }\n        }\n\n        public static void WriteNumberValue(this global::System.Text.Json.Utf8JsonWriter writer, global::System.DateTimeOffset value, string format)\n        {\n            if ((format != \u0022U\u0022))\n            {\n                throw new global::System.ArgumentOutOfRangeException(nameof(format), \u0022Only \u0027U\u0027 format is supported when writing a DateTimeOffset as a Number.\u0022);\n            }\n            writer.WriteNumberValue(value.ToUnixTimeSeconds());\n        }\n\n        public static void WriteObjectValue\u003CT\u003E(this global::System.Text.Json.Utf8JsonWriter writer, T value, global::System.ClientModel.Primitives.ModelReaderWriterOptions options = ((global::System.ClientModel.Primitives.ModelReaderWriterOptions)null))\n        {\n            switch (value)\n            {\n                case null:\n                    writer.WriteNullValue();\n                    break;\n                case global::System.ClientModel.Primitives.IJsonModel\u003CT\u003E jsonModel:\n                    jsonModel.Write(writer, (options ?? global::UnbrandedTypeSpec.ModelSerializationExtensions.WireOptions));\n                    break;\n                case global::System.Byte[] bytes:\n                    writer.WriteBase64StringValue(bytes);\n                    break;\n                case global::System.BinaryData bytes0:\n                    writer.WriteBase64StringValue(bytes0);\n                    break;\n                case global::System.Text.Json.JsonElement json:\n                    json.WriteTo(writer);\n                    break;\n                case int i:\n                    writer.WriteNumberValue(i);\n                    break;\n                case decimal d:\n                    writer.WriteNumberValue(d);\n                    break;\n                case double d0:\n                    if (double.IsNaN(d0))\n                    {\n                        writer.WriteStringValue(\u0022NaN\u0022);\n                    }\n                    else\n                    {\n                        writer.WriteNumberValue(d0);\n                    }\n                    break;\n                case float f:\n                    writer.WriteNumberValue(f);\n                    break;\n                case long l:\n                    writer.WriteNumberValue(l);\n                    break;\n                case string s:\n                    writer.WriteStringValue(s);\n                    break;\n                case bool b:\n                    writer.WriteBooleanValue(b);\n                    break;\n                case global::System.Guid g:\n                    writer.WriteStringValue(g);\n                    break;\n                case global::System.DateTimeOffset dateTimeOffset:\n                    writer.WriteStringValue(dateTimeOffset, \u0022O\u0022);\n                    break;\n                case global::System.DateTime dateTime:\n                    writer.WriteStringValue(dateTime, \u0022O\u0022);\n                    break;\n                case global::System.Collections.Generic.IEnumerable\u003Cglobal::System.Collections.Generic.KeyValuePair\u003Cstring, object\u003E\u003E enumerable:\n                    writer.WriteStartObject();\n                    foreach (var pair in enumerable)\n                    {\n                        writer.WritePropertyName(pair.Key);\n                        writer.WriteObjectValue\u003Cobject\u003E(pair.Value, options);\n                    }\n                    writer.WriteEndObject();\n                    break;\n                case global::System.Collections.Generic.IEnumerable\u003Cobject\u003E objectEnumerable:\n                    writer.WriteStartArray();\n                    foreach (var item in objectEnumerable)\n                    {\n                        writer.WriteObjectValue\u003Cobject\u003E(item, options);\n                    }\n                    writer.WriteEndArray();\n                    break;\n                case global::System.TimeSpan timeSpan:\n                    writer.WriteStringValue(timeSpan, \u0022P\u0022);\n                    break;\n                default:\n                    throw new global::System.NotSupportedException($\u0022Not supported type {value.GetType()}\u0022);\n            }\n        }\n\n        public static void WriteObjectValue(this global::System.Text.Json.Utf8JsonWriter writer, object value, global::System.ClientModel.Primitives.ModelReaderWriterOptions options = ((global::System.ClientModel.Primitives.ModelReaderWriterOptions)null))\n        {\n            writer.WriteObjectValue\u003Cobject\u003E(value, options);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "TypeFormatters.cs",
          "typeDeclaration": {
            "name": "TypeFormatters",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Xml;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class TypeFormatters\n    {\n        private const string RoundtripZFormat = \u0022yyyy-MM-ddTHH:mm:ss.fffffffZ\u0022;\n        public const string DefaultNumberFormat = \u0022G\u0022;\n\n        public static string ToString(bool value) =\u003E value ? \u0022true\u0022 : \u0022false\u0022;\n\n        public static string ToString(global::System.DateTime value, string format) =\u003E value.Kind switch\n        {\n            global::System.DateTimeKind.Utc =\u003E global::UnbrandedTypeSpec.TypeFormatters.ToString(((global::System.DateTimeOffset)value), format),\n            _ =\u003E throw new global::System.NotSupportedException($\u0022DateTime {value} has a Kind of {value.Kind}. Generated clients require it to be UTC. You can call DateTime.SpecifyKind to change Kind property value to DateTimeKind.Utc.\u0022)\n        };\n\n        public static string ToString(global::System.DateTimeOffset value, string format) =\u003E format switch\n        {\n            \u0022D\u0022 =\u003E value.ToString(\u0022yyyy-MM-dd\u0022, global::System.Globalization.CultureInfo.InvariantCulture),\n            \u0022U\u0022 =\u003E value.ToUnixTimeSeconds().ToString(global::System.Globalization.CultureInfo.InvariantCulture),\n            \u0022O\u0022 =\u003E value.ToUniversalTime().ToString(RoundtripZFormat, global::System.Globalization.CultureInfo.InvariantCulture),\n            \u0022o\u0022 =\u003E value.ToUniversalTime().ToString(RoundtripZFormat, global::System.Globalization.CultureInfo.InvariantCulture),\n            \u0022R\u0022 =\u003E value.ToString(\u0022r\u0022, global::System.Globalization.CultureInfo.InvariantCulture),\n            _ =\u003E value.ToString(format, global::System.Globalization.CultureInfo.InvariantCulture)\n        };\n\n        public static string ToString(global::System.TimeSpan value, string format) =\u003E format switch\n        {\n            \u0022P\u0022 =\u003E global::System.Xml.XmlConvert.ToString(value),\n            _ =\u003E value.ToString(format, global::System.Globalization.CultureInfo.InvariantCulture)\n        };\n\n        public static string ToString(global::System.Byte[] value, string format) =\u003E format switch\n        {\n            \u0022U\u0022 =\u003E global::UnbrandedTypeSpec.TypeFormatters.ToBase64UrlString(value),\n            \u0022D\u0022 =\u003E global::System.Convert.ToBase64String(value),\n            _ =\u003E throw new global::System.ArgumentException($\u0022Format is not supported: \u0027{format}\u0027\u0022, nameof(format))\n        };\n\n        public static string ToBase64UrlString(global::System.Byte[] value)\n        {\n            int numWholeOrPartialInputBlocks = (checked (value.Length \u002B 2) / 3);\n            int size = checked (numWholeOrPartialInputBlocks * 4);\n            global::System.Char[] output = new char[size];\n\n            int numBase64Chars = global::System.Convert.ToBase64CharArray(value, 0, value.Length, output, 0);\n\n            int i = 0;\n            for (; (i \u003C numBase64Chars); i\u002B\u002B)\n            {\n                char ch = output[i];\n                if ((ch == \u0027\u002B\u0027))\n                {\n                    output[i] = \u0027-\u0027;\n                }\n                else\n                {\n                    if ((ch == \u0027/\u0027))\n                    {\n                        output[i] = \u0027_\u0027;\n                    }\n                    else\n                    {\n                        if ((ch == \u0027=\u0027))\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return new string(output, 0, i);\n        }\n\n        public static global::System.Byte[] FromBase64UrlString(string value)\n        {\n            int paddingCharsToAdd = (value.Length % 4) switch\n            {\n                0 =\u003E 0,\n                2 =\u003E 2,\n                3 =\u003E 1,\n                _ =\u003E throw new global::System.InvalidOperationException(\u0022Malformed input\u0022)\n            };\n            global::System.Char[] output = new char[(value.Length \u002B paddingCharsToAdd)];\n            int i = 0;\n            for (; (i \u003C value.Length); i\u002B\u002B)\n            {\n                char ch = value[i];\n                if ((ch == \u0027-\u0027))\n                {\n                    output[i] = \u0027\u002B\u0027;\n                }\n                else\n                {\n                    if ((ch == \u0027_\u0027))\n                    {\n                        output[i] = \u0027/\u0027;\n                    }\n                    else\n                    {\n                        output[i] = ch;\n                    }\n                }\n            }\n\n            for (; (i \u003C output.Length); i\u002B\u002B)\n            {\n                output[i] = \u0027=\u0027;\n            }\n\n            return global::System.Convert.FromBase64CharArray(output, 0, output.Length);\n        }\n\n        public static global::System.DateTimeOffset ParseDateTimeOffset(string value, string format) =\u003E format switch\n        {\n            \u0022U\u0022 =\u003E global::System.DateTimeOffset.FromUnixTimeSeconds(long.Parse(value, global::System.Globalization.CultureInfo.InvariantCulture)),\n            _ =\u003E global::System.DateTimeOffset.Parse(value, global::System.Globalization.CultureInfo.InvariantCulture, global::System.Globalization.DateTimeStyles.AssumeUniversal)\n        };\n\n        public static global::System.TimeSpan ParseTimeSpan(string value, string format) =\u003E format switch\n        {\n            \u0022P\u0022 =\u003E global::System.Xml.XmlConvert.ToTimeSpan(value),\n            _ =\u003E global::System.TimeSpan.ParseExact(value, format, global::System.Globalization.CultureInfo.InvariantCulture)\n        };\n\n        public static string ConvertToString(object value, string format = ((string)null)) =\u003E value switch\n        {\n            null =\u003E \u0022null\u0022,\n            string s =\u003E s,\n            bool b =\u003E global::UnbrandedTypeSpec.TypeFormatters.ToString(b),\n            (int  or  (float  or  (double  or  (long  or  decimal)))) =\u003E ((global::System.IFormattable)value).ToString(DefaultNumberFormat, global::System.Globalization.CultureInfo.InvariantCulture),\n            global::System.Byte[] b0 when (format != null) =\u003E global::UnbrandedTypeSpec.TypeFormatters.ToString(b0, format),\n            global::System.Collections.Generic.IEnumerable\u003Cstring\u003E s0 =\u003E string.Join(\u0022,\u0022, s0),\n            global::System.DateTimeOffset dateTime when (format != null) =\u003E global::UnbrandedTypeSpec.TypeFormatters.ToString(dateTime, format),\n            global::System.TimeSpan timeSpan when (format != null) =\u003E global::UnbrandedTypeSpec.TypeFormatters.ToString(timeSpan, format),\n            global::System.TimeSpan timeSpan0 =\u003E global::System.Xml.XmlConvert.ToString(timeSpan0),\n            global::System.Guid guid =\u003E guid.ToString(),\n            global::System.BinaryData binaryData =\u003E global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(binaryData.ToArray(), format),\n            _ =\u003E value.ToString()\n        };\n    }\n}\n"
          }
        },
        {
          "name": "ClientPipelineExtensions.cs",
          "typeDeclaration": {
            "name": "ClientPipelineExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Threading.Tasks;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class ClientPipelineExtensions\n    {\n        public static async global::System.Threading.Tasks.ValueTask\u003Cglobal::System.ClientModel.Primitives.PipelineResponse\u003E ProcessMessageAsync(this global::System.ClientModel.Primitives.ClientPipeline pipeline, global::System.ClientModel.Primitives.PipelineMessage message, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            await pipeline.SendAsync(message).ConfigureAwait(false);\n\n            if ((message.Response.IsError \u0026\u0026 ((options?.ErrorOptions \u0026 global::System.ClientModel.Primitives.ClientErrorBehaviors.NoThrow) != global::System.ClientModel.Primitives.ClientErrorBehaviors.NoThrow)))\n            {\n                throw await global::System.ClientModel.ClientResultException.CreateAsync(message.Response).ConfigureAwait(false);\n            }\n\n            global::System.ClientModel.Primitives.PipelineResponse response = message.BufferResponse ? message.Response : ExtractResponseContent(message);\n            return response;\n        }\n\n        public static global::System.ClientModel.Primitives.PipelineResponse ProcessMessage(this global::System.ClientModel.Primitives.ClientPipeline pipeline, global::System.ClientModel.Primitives.PipelineMessage message, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            pipeline.Send(message);\n\n            if ((message.Response.IsError \u0026\u0026 ((options?.ErrorOptions \u0026 global::System.ClientModel.Primitives.ClientErrorBehaviors.NoThrow) != global::System.ClientModel.Primitives.ClientErrorBehaviors.NoThrow)))\n            {\n                throw new global::System.ClientModel.ClientResultException(message.Response);\n            }\n\n            global::System.ClientModel.Primitives.PipelineResponse response = message.BufferResponse ? message.Response : ExtractResponseContent(message);\n            return response;\n        }\n\n        public static async global::System.Threading.Tasks.ValueTask\u003Cglobal::System.ClientModel.ClientResult\u003Cbool\u003E\u003E ProcessHeadAsBoolMessageAsync(this global::System.ClientModel.Primitives.ClientPipeline pipeline, global::System.ClientModel.Primitives.PipelineMessage message, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineResponse response = await pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false);\n            switch (response.Status)\n            {\n                case ((\u003E= 200) and (\u003C 300)):\n                    return global::System.ClientModel.ClientResult.FromValue\u003Cbool\u003E(true, response);\n                case ((\u003E= 400) and (\u003C 500)):\n                    return global::System.ClientModel.ClientResult.FromValue\u003Cbool\u003E(false, response);\n                default:\n                    return new global::UnbrandedTypeSpec.ErrorResult\u003Cbool\u003E(response, new global::System.ClientModel.ClientResultException(response));\n            }\n        }\n\n        public static global::System.ClientModel.ClientResult\u003Cbool\u003E ProcessHeadAsBoolMessage(this global::System.ClientModel.Primitives.ClientPipeline pipeline, global::System.ClientModel.Primitives.PipelineMessage message, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineResponse response = pipeline.ProcessMessage(message, options);\n            switch (response.Status)\n            {\n                case ((\u003E= 200) and (\u003C 300)):\n                    return global::System.ClientModel.ClientResult.FromValue\u003Cbool\u003E(true, response);\n                case ((\u003E= 400) and (\u003C 500)):\n                    return global::System.ClientModel.ClientResult.FromValue\u003Cbool\u003E(false, response);\n                default:\n                    return new global::UnbrandedTypeSpec.ErrorResult\u003Cbool\u003E(response, new global::System.ClientModel.ClientResultException(response));\n            }\n        }\n\n        private static global::System.ClientModel.Primitives.PipelineResponse ExtractResponseContent(global::System.ClientModel.Primitives.PipelineMessage message)\n        {\n            return message.ExtractResponse();\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ErrorResult.cs",
          "typeDeclaration": {
            "name": "ErrorResult",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ErrorResult\u003CT\u003E : global::System.ClientModel.ClientResult\u003CT\u003E\n    {\n        private readonly global::System.ClientModel.Primitives.PipelineResponse _response;\n        private readonly global::System.ClientModel.ClientResultException _exception;\n\n        public ErrorResult(global::System.ClientModel.Primitives.PipelineResponse response, global::System.ClientModel.ClientResultException exception) : base(default, response)\n        {\n            _response = response;\n            _exception = exception;\n        }\n\n        public override T Value =\u003E throw _exception;\n    }\n}\n"
          }
        },
        {
          "name": "ClientUriBuilder.cs",
          "typeDeclaration": {
            "name": "ClientUriBuilder",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ClientUriBuilder\n    {\n        private global::System.UriBuilder _uriBuilder;\n        private global::System.Text.StringBuilder _pathBuilder;\n        private global::System.Text.StringBuilder _queryBuilder;\n\n        public ClientUriBuilder()\n        {\n        }\n\n        private global::System.UriBuilder UriBuilder =\u003E (_uriBuilder  ??=  new global::System.UriBuilder());\n\n        private global::System.Text.StringBuilder PathBuilder =\u003E (_pathBuilder  ??=  new global::System.Text.StringBuilder(UriBuilder.Path));\n\n        private global::System.Text.StringBuilder QueryBuilder =\u003E (_queryBuilder  ??=  new global::System.Text.StringBuilder(UriBuilder.Query));\n\n        public void Reset(global::System.Uri uri)\n        {\n            _uriBuilder = new global::System.UriBuilder(uri);\n            _pathBuilder = new global::System.Text.StringBuilder(UriBuilder.Path);\n            _queryBuilder = new global::System.Text.StringBuilder(UriBuilder.Query);\n        }\n\n        public void AppendPath(string value, bool escape)\n        {\n            if (escape)\n            {\n                value = global::System.Uri.EscapeDataString(value);\n            }\n            if ((((PathBuilder.Length \u003E 0) \u0026\u0026 (PathBuilder[(PathBuilder.Length - 1)] == \u0027/\u0027)) \u0026\u0026 (value[0] == \u0027/\u0027)))\n            {\n                PathBuilder.Remove((PathBuilder.Length - 1), 1);\n            }\n            PathBuilder.Append(value);\n            UriBuilder.Path = PathBuilder.ToString();\n        }\n\n        public void AppendPath(bool value, bool escape = false) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(float value, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(double value, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(int value, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(global::System.Byte[] value, string format, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendPath(global::System.Collections.Generic.IEnumerable\u003Cstring\u003E value, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(global::System.DateTimeOffset value, string format, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendPath(global::System.TimeSpan value, string format, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendPath(global::System.Guid value, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(long value, bool escape = true) =\u003E AppendPath(global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, string value, bool escape)\n        {\n            if ((QueryBuilder.Length \u003E 0))\n            {\n                QueryBuilder.Append(\u0027\u0026\u0027);\n            }\n            if (escape)\n            {\n                value = global::System.Uri.EscapeDataString(value);\n            }\n            QueryBuilder.Append(name);\n            QueryBuilder.Append(\u0027=\u0027);\n            QueryBuilder.Append(value);\n        }\n\n        public void AppendQuery(string name, bool value, bool escape = false) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, float value, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, global::System.DateTimeOffset value, string format, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendQuery(string name, global::System.TimeSpan value, string format, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendQuery(string name, double value, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, decimal value, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, int value, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, long value, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, global::System.TimeSpan value, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, global::System.Byte[] value, string format, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendQuery(string name, global::System.Guid value, bool escape = true) =\u003E AppendQuery(name, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(value), escape);\n\n        public global::System.Uri ToUri()\n        {\n            if ((_pathBuilder != null))\n            {\n                UriBuilder.Path = _pathBuilder.ToString();\n            }\n            if ((_queryBuilder != null))\n            {\n                UriBuilder.Query = _queryBuilder.ToString();\n            }\n            return UriBuilder.Uri;\n        }\n\n        public void AppendQueryDelimited\u003CT\u003E(string name, global::System.Collections.Generic.IEnumerable\u003CT\u003E value, string delimiter, bool escape = true)\n        {\n            global::System.Collections.Generic.IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(v));\n            AppendQuery(name, string.Join(delimiter, stringValues), escape);\n        }\n\n        public void AppendQueryDelimited\u003CT\u003E(string name, global::System.Collections.Generic.IEnumerable\u003CT\u003E value, string delimiter, string format, bool escape = true)\n        {\n            global::System.Collections.Generic.IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(v, format));\n            AppendQuery(name, string.Join(delimiter, stringValues), escape);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Utf8JsonBinaryContent.cs",
          "typeDeclaration": {
            "name": "Utf8JsonBinaryContent",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel;\nusing System.IO;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class Utf8JsonBinaryContent : global::System.ClientModel.BinaryContent\n    {\n        private readonly global::System.IO.MemoryStream _stream;\n        private readonly global::System.ClientModel.BinaryContent _content;\n\n        public Utf8JsonBinaryContent()\n        {\n            _stream = new global::System.IO.MemoryStream();\n            _content = global::System.ClientModel.BinaryContent.Create(_stream);\n            JsonWriter = new global::System.Text.Json.Utf8JsonWriter(_stream);\n        }\n\n        public global::System.Text.Json.Utf8JsonWriter JsonWriter { get; }\n\n        public override async global::System.Threading.Tasks.Task WriteToAsync(global::System.IO.Stream stream, global::System.Threading.CancellationToken cancellationToken = ((global::System.Threading.CancellationToken)default))\n        {\n            await JsonWriter.FlushAsync().ConfigureAwait(false);\n            await _content.WriteToAsync(stream, cancellationToken).ConfigureAwait(false);\n        }\n\n        public override void WriteTo(global::System.IO.Stream stream, global::System.Threading.CancellationToken cancellationToken = ((global::System.Threading.CancellationToken)default))\n        {\n            JsonWriter.Flush();\n            _content.WriteTo(stream, cancellationToken);\n        }\n\n        public override bool TryComputeLength(out long length)\n        {\n            length = (JsonWriter.BytesCommitted \u002B JsonWriter.BytesPending);\n            return true;\n        }\n\n        public override void Dispose()\n        {\n            JsonWriter.Dispose();\n            _content.Dispose();\n            _stream.Dispose();\n        }\n    }\n}\n"
          }
        },
        {
          "name": "BinaryContentHelper.cs",
          "typeDeclaration": {
            "name": "BinaryContentHelper",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class BinaryContentHelper\n    {\n        public static global::System.ClientModel.BinaryContent FromEnumerable\u003CT\u003E(global::System.Collections.Generic.IEnumerable\u003CT\u003E enumerable)\n            where T : notnull \n        {\n            global::UnbrandedTypeSpec.Utf8JsonBinaryContent content = new global::UnbrandedTypeSpec.Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartArray();\n            foreach (var item in enumerable)\n            {\n                content.JsonWriter.WriteObjectValue\u003CT\u003E(item, global::UnbrandedTypeSpec.ModelSerializationExtensions.WireOptions);\n            }\n            content.JsonWriter.WriteEndArray();\n\n            return content;\n        }\n\n        public static global::System.ClientModel.BinaryContent FromEnumerable(global::System.Collections.Generic.IEnumerable\u003Cglobal::System.BinaryData\u003E enumerable)\n        {\n            global::UnbrandedTypeSpec.Utf8JsonBinaryContent content = new global::UnbrandedTypeSpec.Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartArray();\n            foreach (var item in enumerable)\n            {\n                if ((item == null))\n                {\n                    content.JsonWriter.WriteNullValue();\n                }\n                else\n                {\n#if NET6_0_OR_GREATER\n                    content.JsonWriter.WriteRawValue(item);\n#else\n                    using (global::System.Text.Json.JsonDocument document = global::System.Text.Json.JsonDocument.Parse(item))\n                    {\n                        global::System.Text.Json.JsonSerializer.Serialize(content.JsonWriter, document.RootElement);\n                    }\n#endif\n                }\n            }\n            content.JsonWriter.WriteEndArray();\n\n            return content;\n        }\n\n        public static global::System.ClientModel.BinaryContent FromEnumerable\u003CT\u003E(global::System.ReadOnlySpan\u003CT\u003E span)\n            where T : notnull \n        {\n            global::UnbrandedTypeSpec.Utf8JsonBinaryContent content = new global::UnbrandedTypeSpec.Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartArray();\n            int i = 0;\n            for (; (i \u003C span.Length); i\u002B\u002B)\n            {\n                content.JsonWriter.WriteObjectValue\u003CT\u003E(span[i], global::UnbrandedTypeSpec.ModelSerializationExtensions.WireOptions);\n            }\n            content.JsonWriter.WriteEndArray();\n\n            return content;\n        }\n\n        public static global::System.ClientModel.BinaryContent FromDictionary\u003CTValue\u003E(global::System.Collections.Generic.IDictionary\u003Cstring, TValue\u003E dictionary)\n            where TValue : notnull \n        {\n            global::UnbrandedTypeSpec.Utf8JsonBinaryContent content = new global::UnbrandedTypeSpec.Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartObject();\n            foreach (var item in dictionary)\n            {\n                content.JsonWriter.WritePropertyName(item.Key);\n                content.JsonWriter.WriteObjectValue\u003CTValue\u003E(item.Value, global::UnbrandedTypeSpec.ModelSerializationExtensions.WireOptions);\n            }\n            content.JsonWriter.WriteEndObject();\n\n            return content;\n        }\n\n        public static global::System.ClientModel.BinaryContent FromDictionary(global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E dictionary)\n        {\n            global::UnbrandedTypeSpec.Utf8JsonBinaryContent content = new global::UnbrandedTypeSpec.Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartObject();\n            foreach (var item in dictionary)\n            {\n                content.JsonWriter.WritePropertyName(item.Key);\n                if ((item.Value == null))\n                {\n                    content.JsonWriter.WriteNullValue();\n                }\n                else\n                {\n#if NET6_0_OR_GREATER\n                    content.JsonWriter.WriteRawValue(item.Value);\n#else\n                    using (global::System.Text.Json.JsonDocument document = global::System.Text.Json.JsonDocument.Parse(item.Value))\n                    {\n                        global::System.Text.Json.JsonSerializer.Serialize(content.JsonWriter, document.RootElement);\n                    }\n#endif\n                }\n            }\n            content.JsonWriter.WriteEndObject();\n\n            return content;\n        }\n\n        public static global::System.ClientModel.BinaryContent FromObject(object value)\n        {\n            global::UnbrandedTypeSpec.Utf8JsonBinaryContent content = new global::UnbrandedTypeSpec.Utf8JsonBinaryContent();\n            content.JsonWriter.WriteObjectValue\u003Cobject\u003E(value, global::UnbrandedTypeSpec.ModelSerializationExtensions.WireOptions);\n            return content;\n        }\n\n        public static global::System.ClientModel.BinaryContent FromObject(global::System.BinaryData value)\n        {\n            global::UnbrandedTypeSpec.Utf8JsonBinaryContent content = new global::UnbrandedTypeSpec.Utf8JsonBinaryContent();\n#if NET6_0_OR_GREATER\n            content.JsonWriter.WriteRawValue(value);\n#else\n            using (global::System.Text.Json.JsonDocument document = global::System.Text.Json.JsonDocument.Parse(value))\n            {\n                global::System.Text.Json.JsonSerializer.Serialize(content.JsonWriter, document.RootElement);\n            }\n#endif\n            return content;\n        }\n    }\n}\n"
          }
        },
        {
          "name": "PipelineRequestHeadersExtensions.cs",
          "typeDeclaration": {
            "name": "PipelineRequestHeadersExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class PipelineRequestHeadersExtensions\n    {\n        public static void SetDelimited\u003CT\u003E(this global::System.ClientModel.Primitives.PipelineRequestHeaders headers, string name, global::System.Collections.Generic.IEnumerable\u003CT\u003E value, string delimiter)\n        {\n            global::System.Collections.Generic.IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(v));\n            headers.Set(name, string.Join(delimiter, stringValues));\n        }\n\n        public static void SetDelimited\u003CT\u003E(this global::System.ClientModel.Primitives.PipelineRequestHeaders headers, string name, global::System.Collections.Generic.IEnumerable\u003CT\u003E value, string delimiter, string format)\n        {\n            global::System.Collections.Generic.IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(v, format));\n            headers.Set(name, string.Join(delimiter, stringValues));\n        }\n    }\n}\n"
          }
        }
      ]
    },
    {
      "name": "src\\Generated",
      "files": [
        {
          "name": "UnbrandedTypeSpecModelFactory.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecModelFactory",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E A factory class for creating instances of the models for mocking. \u003C/summary\u003E\n    public static partial class UnbrandedTypeSpecModelFactory\n    {\n        /// \u003Csummary\u003E A model with a few properties of literal types. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralString\u0022\u003E required literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralInt\u0022\u003E required literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralFloat\u0022\u003E required literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralBool\u0022\u003E required literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralString\u0022\u003E optional literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralInt\u0022\u003E optional literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralFloat\u0022\u003E optional literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralBool\u0022\u003E optional literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalNullableList\u0022\u003E optional nullable collection. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.Thing\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static global::UnbrandedTypeSpec.Models.Thing Thing(string name = default, global::System.BinaryData requiredUnion = default, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString requiredLiteralString = default, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt requiredLiteralInt = default, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat requiredLiteralFloat = default, bool requiredLiteralBool = default, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString? optionalLiteralString = default, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt? optionalLiteralInt = default, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat? optionalLiteralFloat = default, bool? optionalLiteralBool = default, string requiredBadDescription = default, global::System.Collections.Generic.IEnumerable\u003Cint\u003E optionalNullableList = default, global::System.Collections.Generic.IEnumerable\u003Cint\u003E requiredNullableList = default)\n        {\n            optionalNullableList ??= new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cint\u003E();\n            requiredNullableList ??= new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cint\u003E();\n\n            return new global::UnbrandedTypeSpec.Models.Thing(\n                name,\n                requiredUnion,\n                requiredLiteralString,\n                requiredLiteralInt,\n                requiredLiteralFloat,\n                requiredLiteralBool,\n                optionalLiteralString,\n                optionalLiteralInt,\n                optionalLiteralFloat,\n                optionalLiteralBool,\n                requiredBadDescription,\n                optionalNullableList?.ToList(),\n                requiredNullableList?.ToList(),\n                null);\n        }\n\n        /// \u003Csummary\u003E this is a roundtrip model. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredString\u0022\u003E Required string, illustrating a reference type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredInt\u0022\u003E Required int, illustrating a value type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredCollection\u0022\u003E Required collection of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredDictionary\u0022\u003E Required dictionary of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredModel\u0022\u003E Required model. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intExtensibleEnum\u0022\u003E this is an int based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intExtensibleEnumCollection\u0022\u003E this is a collection of int based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatExtensibleEnum\u0022\u003E this is a float based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatExtensibleEnumWithIntValue\u0022\u003E this is a float based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatExtensibleEnumCollection\u0022\u003E this is a collection of float based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatFixedEnum\u0022\u003E this is a float based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatFixedEnumWithIntValue\u0022\u003E this is a float based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatFixedEnumCollection\u0022\u003E this is a collection of float based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intFixedEnum\u0022\u003E this is a int based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intFixedEnumCollection\u0022\u003E this is a collection of int based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022stringFixedEnum\u0022\u003E this is a string based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnknown\u0022\u003E required unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalUnknown\u0022\u003E optional unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredRecordUnknown\u0022\u003E required record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalRecordUnknown\u0022\u003E optional record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022readOnlyRequiredRecordUnknown\u0022\u003E required readonly record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022readOnlyOptionalRecordUnknown\u0022\u003E optional readonly record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022modelWithRequiredNullable\u0022\u003E this is a model with required nullable properties. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBytes\u0022\u003E Required bytes. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.RoundTripModel\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static global::UnbrandedTypeSpec.Models.RoundTripModel RoundTripModel(string requiredString = default, int requiredInt = default, global::System.Collections.Generic.IEnumerable\u003Cglobal::UnbrandedTypeSpec.Models.StringFixedEnum\u003E requiredCollection = default, global::System.Collections.Generic.IDictionary\u003Cstring, global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u003E requiredDictionary = default, global::UnbrandedTypeSpec.Models.Thing requiredModel = default, global::UnbrandedTypeSpec.Models.IntExtensibleEnum? intExtensibleEnum = default, global::System.Collections.Generic.IEnumerable\u003Cglobal::UnbrandedTypeSpec.Models.IntExtensibleEnum\u003E intExtensibleEnumCollection = default, global::UnbrandedTypeSpec.Models.FloatExtensibleEnum? floatExtensibleEnum = default, global::UnbrandedTypeSpec.Models.FloatExtensibleEnumWithIntValue? floatExtensibleEnumWithIntValue = default, global::System.Collections.Generic.IEnumerable\u003Cglobal::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u003E floatExtensibleEnumCollection = default, global::UnbrandedTypeSpec.Models.FloatFixedEnum? floatFixedEnum = default, global::UnbrandedTypeSpec.Models.FloatFixedEnumWithIntValue? floatFixedEnumWithIntValue = default, global::System.Collections.Generic.IEnumerable\u003Cglobal::UnbrandedTypeSpec.Models.FloatFixedEnum\u003E floatFixedEnumCollection = default, global::UnbrandedTypeSpec.Models.IntFixedEnum? intFixedEnum = default, global::System.Collections.Generic.IEnumerable\u003Cglobal::UnbrandedTypeSpec.Models.IntFixedEnum\u003E intFixedEnumCollection = default, global::UnbrandedTypeSpec.Models.StringFixedEnum? stringFixedEnum = default, global::System.BinaryData requiredUnknown = default, global::System.BinaryData optionalUnknown = default, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E requiredRecordUnknown = default, global::System.Collections.Generic.IDictionary\u003Cstring, global::System.BinaryData\u003E optionalRecordUnknown = default, global::System.Collections.Generic.IReadOnlyDictionary\u003Cstring, global::System.BinaryData\u003E readOnlyRequiredRecordUnknown = default, global::System.Collections.Generic.IReadOnlyDictionary\u003Cstring, global::System.BinaryData\u003E readOnlyOptionalRecordUnknown = default, global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties modelWithRequiredNullable = default, global::System.BinaryData requiredBytes = default)\n        {\n            requiredCollection ??= new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.StringFixedEnum\u003E();\n            requiredDictionary ??= new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::UnbrandedTypeSpec.Models.StringExtensibleEnum\u003E();\n            intExtensibleEnumCollection ??= new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.IntExtensibleEnum\u003E();\n            floatExtensibleEnumCollection ??= new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.FloatExtensibleEnum\u003E();\n            floatFixedEnumCollection ??= new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.FloatFixedEnum\u003E();\n            intFixedEnumCollection ??= new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cglobal::UnbrandedTypeSpec.Models.IntFixedEnum\u003E();\n            requiredRecordUnknown ??= new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::System.BinaryData\u003E();\n            optionalRecordUnknown ??= new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::System.BinaryData\u003E();\n            readOnlyRequiredRecordUnknown ??= new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::System.BinaryData\u003E();\n            readOnlyOptionalRecordUnknown ??= new global::UnbrandedTypeSpec.ChangeTrackingDictionary\u003Cstring, global::System.BinaryData\u003E();\n\n            return new global::UnbrandedTypeSpec.Models.RoundTripModel(\n                requiredString,\n                requiredInt,\n                requiredCollection?.ToList(),\n                requiredDictionary,\n                requiredModel,\n                intExtensibleEnum,\n                intExtensibleEnumCollection?.ToList(),\n                floatExtensibleEnum,\n                floatExtensibleEnumWithIntValue,\n                floatExtensibleEnumCollection?.ToList(),\n                floatFixedEnum,\n                floatFixedEnumWithIntValue,\n                floatFixedEnumCollection?.ToList(),\n                intFixedEnum,\n                intFixedEnumCollection?.ToList(),\n                stringFixedEnum,\n                requiredUnknown,\n                optionalUnknown,\n                requiredRecordUnknown,\n                optionalRecordUnknown,\n                readOnlyRequiredRecordUnknown,\n                readOnlyOptionalRecordUnknown,\n                modelWithRequiredNullable,\n                requiredBytes,\n                null);\n        }\n\n        /// \u003Csummary\u003E A model with a few required nullable properties. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredNullablePrimitive\u0022\u003E required nullable primitive type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredExtensibleEnum\u0022\u003E required nullable extensible enum type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredFixedEnum\u0022\u003E required nullable fixed enum type. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties ModelWithRequiredNullableProperties(int? requiredNullablePrimitive = default, global::UnbrandedTypeSpec.Models.StringExtensibleEnum? requiredExtensibleEnum = default, global::UnbrandedTypeSpec.Models.StringFixedEnum? requiredFixedEnum = default)\n        {\n\n            return new global::UnbrandedTypeSpec.Models.ModelWithRequiredNullableProperties(requiredNullablePrimitive, requiredExtensibleEnum, requiredFixedEnum, null);\n        }\n\n        /// \u003Csummary\u003E this is not a friendly model but with a friendly name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the NotFriend. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.Friend\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static global::UnbrandedTypeSpec.Models.Friend Friend(string name = default)\n        {\n\n            return new global::UnbrandedTypeSpec.Models.Friend(name, null);\n        }\n\n        /// \u003Csummary\u003E this is a model with a projected name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the ModelWithProjectedName. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ProjectedModel\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static global::UnbrandedTypeSpec.Models.ProjectedModel ProjectedModel(string name = default)\n        {\n\n            return new global::UnbrandedTypeSpec.Models.ProjectedModel(name, null);\n        }\n\n        /// \u003Csummary\u003E The ReturnsAnonymousModelResponse. \u003C/summary\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022global::UnbrandedTypeSpec.Models.ReturnsAnonymousModelResponse\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static global::UnbrandedTypeSpec.Models.ReturnsAnonymousModelResponse ReturnsAnonymousModelResponse()\n        {\n\n            return new global::UnbrandedTypeSpec.Models.ReturnsAnonymousModelResponse(null);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "UnbrandedTypeSpecClient.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecClient",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnbrandedTypeSpec.Models;\n\nnamespace UnbrandedTypeSpec\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class UnbrandedTypeSpecClient\n    {\n        private readonly global::System.Uri _endpoint;\n        private const string AuthorizationHeader = \u0022my-api-key\u0022;\n        /// \u003Csummary\u003E A credential used to authenticate to the service. \u003C/summary\u003E\n        private readonly global::System.ClientModel.ApiKeyCredential _keyCredential;\n        private readonly string _apiVersion;\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClient for mocking. \u003C/summary\u003E\n        protected UnbrandedTypeSpecClient()\n        {\n        }\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClient. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022endpoint\u0022\u003E Service endpoint. \u003C/param\u003E\n        /// \u003Cparam name=\u0022keyCredential\u0022\u003E A credential used to authenticate to the service. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022endpoint\u0022/\u003E or \u003Cparamref name=\u0022keyCredential\u0022/\u003E is null. \u003C/exception\u003E\n        public UnbrandedTypeSpecClient(global::System.Uri endpoint, global::System.ClientModel.ApiKeyCredential keyCredential) : this(endpoint, keyCredential, new global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions())\n        {\n        }\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClient. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022endpoint\u0022\u003E Service endpoint. \u003C/param\u003E\n        /// \u003Cparam name=\u0022keyCredential\u0022\u003E A credential used to authenticate to the service. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The options for configuring the client. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022endpoint\u0022/\u003E or \u003Cparamref name=\u0022keyCredential\u0022/\u003E is null. \u003C/exception\u003E\n        public UnbrandedTypeSpecClient(global::System.Uri endpoint, global::System.ClientModel.ApiKeyCredential keyCredential, global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(endpoint, nameof(endpoint));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(keyCredential, nameof(keyCredential));\n\n            options ??= new global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions();\n\n            _endpoint = endpoint;\n            _keyCredential = keyCredential;\n            Pipeline = global::System.ClientModel.Primitives.ClientPipeline.Create(options, Array.Empty\u003Cglobal::System.ClientModel.Primitives.PipelinePolicy\u003E(), new global::System.ClientModel.Primitives.PipelinePolicy[] { global::System.ClientModel.Primitives.ApiKeyAuthenticationPolicy.CreateHeaderApiKeyPolicy(_keyCredential, AuthorizationHeader) }, Array.Empty\u003Cglobal::System.ClientModel.Primitives.PipelinePolicy\u003E());\n            _apiVersion = options.Version;\n        }\n\n        /// \u003Csummary\u003E The HTTP pipeline for sending and receiving REST requests and responses. \u003C/summary\u003E\n        public global::System.ClientModel.Primitives.ClientPipeline Pipeline { get; }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult SayHi(string headParameter, string queryParameter, string optionalQuery, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(headParameter, nameof(headParameter));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateSayHiRequest(headParameter, queryParameter, optionalQuery, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E SayHiAsync(string headParameter, string queryParameter, string optionalQuery, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(headParameter, nameof(headParameter));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateSayHiRequest(headParameter, queryParameter, optionalQuery, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E SayHi(string headParameter, string queryParameter, string optionalQuery)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(headParameter, nameof(headParameter));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            global::System.ClientModel.ClientResult result = this.SayHi(headParameter, queryParameter, optionalQuery, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Return hi. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E\u003E SayHiAsync(string headParameter, string queryParameter, string optionalQuery)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(headParameter, nameof(headParameter));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            global::System.ClientModel.ClientResult result = await this.SayHiAsync(headParameter, queryParameter, optionalQuery, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult HelloAgain(string p2, string p1, global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p2, nameof(p2));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHelloAgainRequest(p2, p1, content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E HelloAgainAsync(string p2, string p1, global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p2, nameof(p2));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHelloAgainRequest(p2, p1, content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022action\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.RoundTripModel\u003E HelloAgain(string p2, string p1, global::UnbrandedTypeSpec.Models.RoundTripModel action)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p2, nameof(p2));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(action, nameof(action));\n\n            global::System.ClientModel.ClientResult result = this.HelloAgain(p2, p1, action, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.RoundTripModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022action\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.RoundTripModel\u003E\u003E HelloAgainAsync(string p2, string p1, global::UnbrandedTypeSpec.Models.RoundTripModel action)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p2, nameof(p2));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(action, nameof(action));\n\n            global::System.ClientModel.ClientResult result = await this.HelloAgainAsync(p2, p1, action, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.RoundTripModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult NoContentType(string p2, string p1, global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p2, nameof(p2));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateNoContentTypeRequest(p2, p1, content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E NoContentTypeAsync(string p2, string p1, global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p2, nameof(p2));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateNoContentTypeRequest(p2, p1, content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi in demo2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult HelloDemo2(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHelloDemo2Request(options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi in demo2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E HelloDemo2Async(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHelloDemo2Request(options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi in demo2. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E HelloDemo2()\n        {\n            global::System.ClientModel.ClientResult result = this.HelloDemo2(null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Return hi in demo2. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E\u003E HelloDemo2Async()\n        {\n            global::System.ClientModel.ClientResult result = await this.HelloDemo2Async(null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Create with literal value\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult CreateLiteral(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateCreateLiteralRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Create with literal value\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E CreateLiteralAsync(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateCreateLiteralRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Create with literal value. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E CreateLiteral(global::UnbrandedTypeSpec.Models.Thing body)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(body, nameof(body));\n\n            global::System.ClientModel.ClientResult result = this.CreateLiteral(body, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Create with literal value. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E\u003E CreateLiteralAsync(global::UnbrandedTypeSpec.Models.Thing body)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(body, nameof(body));\n\n            global::System.ClientModel.ClientResult result = await this.CreateLiteralAsync(body, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Send literal parameters\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult HelloLiteral(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHelloLiteralRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Send literal parameters\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E HelloLiteralAsync(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHelloLiteralRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Send literal parameters. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E HelloLiteral()\n        {\n            global::System.ClientModel.ClientResult result = this.HelloLiteral(null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Send literal parameters. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E\u003E HelloLiteralAsync()\n        {\n            global::System.ClientModel.ClientResult result = await this.HelloLiteralAsync(null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult TopAction(global::System.DateTimeOffset action, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateTopActionRequest(action, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E TopActionAsync(global::System.DateTimeOffset action, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateTopActionRequest(action, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E top level method. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E TopAction(global::System.DateTimeOffset action)\n        {\n            global::System.ClientModel.ClientResult result = this.TopAction(action, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E top level method. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E\u003E TopActionAsync(global::System.DateTimeOffset action)\n        {\n            global::System.ClientModel.ClientResult result = await this.TopActionAsync(action, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult TopAction2(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateTopAction2Request(options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E TopAction2Async(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateTopAction2Request(options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level patch\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult PatchAction(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreatePatchActionRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level patch\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E PatchActionAsync(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreatePatchActionRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] body parameter without body decorator\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult AnonymousBody(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateAnonymousBodyRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] body parameter without body decorator\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E AnonymousBodyAsync(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateAnonymousBodyRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E body parameter without body decorator. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralString\u0022\u003E required literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralInt\u0022\u003E required literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralFloat\u0022\u003E required literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralBool\u0022\u003E required literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralString\u0022\u003E optional literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralInt\u0022\u003E optional literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralFloat\u0022\u003E optional literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralBool\u0022\u003E optional literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalNullableList\u0022\u003E optional nullable collection. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E, \u003Cparamref name=\u0022requiredUnion\u0022/\u003E or \u003Cparamref name=\u0022requiredBadDescription\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E AnonymousBody(string name, global::System.BinaryData requiredUnion, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString requiredLiteralString, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt requiredLiteralInt, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat requiredLiteralFloat, bool requiredLiteralBool, string requiredBadDescription, global::System.Collections.Generic.IEnumerable\u003Cint\u003E requiredNullableList, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString? optionalLiteralString = default, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt? optionalLiteralInt = default, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat? optionalLiteralFloat = default, bool? optionalLiteralBool = default, global::System.Collections.Generic.IEnumerable\u003Cint\u003E optionalNullableList = default)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(name, nameof(name));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredUnion, nameof(requiredUnion));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredBadDescription, nameof(requiredBadDescription));\n\n            global::UnbrandedTypeSpec.Models.Thing spreadModel = new global::UnbrandedTypeSpec.Models.Thing(\n                name,\n                requiredUnion,\n                requiredLiteralString,\n                requiredLiteralInt,\n                requiredLiteralFloat,\n                requiredLiteralBool,\n                optionalLiteralString,\n                optionalLiteralInt,\n                optionalLiteralFloat,\n                optionalLiteralBool,\n                requiredBadDescription,\n                (optionalNullableList?.ToList() as global::System.Collections.Generic.IList\u003Cint\u003E ?? new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cint\u003E()),\n                (requiredNullableList?.ToList() as global::System.Collections.Generic.IList\u003Cint\u003E ?? new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cint\u003E()),\n                null);\n            global::System.ClientModel.ClientResult result = this.AnonymousBody(spreadModel, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E body parameter without body decorator. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralString\u0022\u003E required literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralInt\u0022\u003E required literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralFloat\u0022\u003E required literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralBool\u0022\u003E required literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralString\u0022\u003E optional literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralInt\u0022\u003E optional literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralFloat\u0022\u003E optional literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralBool\u0022\u003E optional literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalNullableList\u0022\u003E optional nullable collection. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E, \u003Cparamref name=\u0022requiredUnion\u0022/\u003E or \u003Cparamref name=\u0022requiredBadDescription\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E\u003E AnonymousBodyAsync(string name, global::System.BinaryData requiredUnion, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralString requiredLiteralString, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralInt requiredLiteralInt, global::UnbrandedTypeSpec.Models.ThingRequiredLiteralFloat requiredLiteralFloat, bool requiredLiteralBool, string requiredBadDescription, global::System.Collections.Generic.IEnumerable\u003Cint\u003E requiredNullableList, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralString? optionalLiteralString = default, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralInt? optionalLiteralInt = default, global::UnbrandedTypeSpec.Models.ThingOptionalLiteralFloat? optionalLiteralFloat = default, bool? optionalLiteralBool = default, global::System.Collections.Generic.IEnumerable\u003Cint\u003E optionalNullableList = default)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(name, nameof(name));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredUnion, nameof(requiredUnion));\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(requiredBadDescription, nameof(requiredBadDescription));\n\n            global::UnbrandedTypeSpec.Models.Thing spreadModel = new global::UnbrandedTypeSpec.Models.Thing(\n                name,\n                requiredUnion,\n                requiredLiteralString,\n                requiredLiteralInt,\n                requiredLiteralFloat,\n                requiredLiteralBool,\n                optionalLiteralString,\n                optionalLiteralInt,\n                optionalLiteralFloat,\n                optionalLiteralBool,\n                requiredBadDescription,\n                (optionalNullableList?.ToList() as global::System.Collections.Generic.IList\u003Cint\u003E ?? new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cint\u003E()),\n                (requiredNullableList?.ToList() as global::System.Collections.Generic.IList\u003Cint\u003E ?? new global::UnbrandedTypeSpec.ChangeTrackingList\u003Cint\u003E()),\n                null);\n            global::System.ClientModel.ClientResult result = await this.AnonymousBodyAsync(spreadModel, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its friendly name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult FriendlyModel(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateFriendlyModelRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its friendly name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E FriendlyModelAsync(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateFriendlyModelRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Model can have its friendly name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the NotFriend. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Friend\u003E FriendlyModel(string name)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(name, nameof(name));\n\n            global::UnbrandedTypeSpec.Models.Friend spreadModel = new global::UnbrandedTypeSpec.Models.Friend(name, null);\n            global::System.ClientModel.ClientResult result = this.FriendlyModel(spreadModel, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Friend)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Model can have its friendly name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the NotFriend. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Friend\u003E\u003E FriendlyModelAsync(string name)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(name, nameof(name));\n\n            global::UnbrandedTypeSpec.Models.Friend spreadModel = new global::UnbrandedTypeSpec.Models.Friend(name, null);\n            global::System.ClientModel.ClientResult result = await this.FriendlyModelAsync(spreadModel, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Friend)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] addTimeHeader\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult AddTimeHeader(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateAddTimeHeaderRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] addTimeHeader\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E AddTimeHeaderAsync(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateAddTimeHeaderRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E addTimeHeader. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult AddTimeHeader()\n        {\n            return this.AddTimeHeader(null);\n        }\n\n        /// \u003Csummary\u003E addTimeHeader. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E AddTimeHeaderAsync()\n        {\n            return await this.AddTimeHeaderAsync(null).ConfigureAwait(false);\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its projected name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult ProjectedNameModel(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateProjectedNameModelRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its projected name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E ProjectedNameModelAsync(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateProjectedNameModelRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Model can have its projected name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the ModelWithProjectedName. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.ProjectedModel\u003E ProjectedNameModel(string name)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(name, nameof(name));\n\n            global::UnbrandedTypeSpec.Models.ProjectedModel spreadModel = new global::UnbrandedTypeSpec.Models.ProjectedModel(name, null);\n            global::System.ClientModel.ClientResult result = this.ProjectedNameModel(spreadModel, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.ProjectedModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Model can have its projected name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the ModelWithProjectedName. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.ProjectedModel\u003E\u003E ProjectedNameModelAsync(string name)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(name, nameof(name));\n\n            global::UnbrandedTypeSpec.Models.ProjectedModel spreadModel = new global::UnbrandedTypeSpec.Models.ProjectedModel(name, null);\n            global::System.ClientModel.ClientResult result = await this.ProjectedNameModelAsync(spreadModel, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.ProjectedModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] return anonymous model\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult ReturnsAnonymousModel(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateReturnsAnonymousModelRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] return anonymous model\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E ReturnsAnonymousModelAsync(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateReturnsAnonymousModelRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E return anonymous model. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.ReturnsAnonymousModelResponse\u003E ReturnsAnonymousModel()\n        {\n            global::System.ClientModel.ClientResult result = this.ReturnsAnonymousModel(null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.ReturnsAnonymousModelResponse)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E return anonymous model. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.ReturnsAnonymousModelResponse\u003E\u003E ReturnsAnonymousModelAsync()\n        {\n            global::System.ClientModel.ClientResult result = await this.ReturnsAnonymousModelAsync(null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.ReturnsAnonymousModelResponse)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] get extensible enum\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult GetUnknownValue(string accept, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(accept, nameof(accept));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateGetUnknownValueRequest(accept, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] get extensible enum\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E GetUnknownValueAsync(string accept, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(accept, nameof(accept));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateGetUnknownValueRequest(accept, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E get extensible enum. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cstring\u003E GetUnknownValue(string accept)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(accept, nameof(accept));\n\n            global::System.ClientModel.ClientResult result = this.GetUnknownValue(accept, null);\n            return global::System.ClientModel.ClientResult.FromValue(result.GetRawResponse().Content.ToObjectFromJson\u003Cstring\u003E(), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E get extensible enum. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cstring\u003E\u003E GetUnknownValueAsync(string accept)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(accept, nameof(accept));\n\n            global::System.ClientModel.ClientResult result = await this.GetUnknownValueAsync(accept, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(result.GetRawResponse().Content.ToObjectFromJson\u003Cstring\u003E(), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, then the protocol method should be internal\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult InternalProtocol(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateInternalProtocolRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, then the protocol method should be internal\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E InternalProtocolAsync(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(content, nameof(content));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateInternalProtocolRequest(content, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, then the protocol method should be internal. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E InternalProtocol(global::UnbrandedTypeSpec.Models.Thing body)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(body, nameof(body));\n\n            global::System.ClientModel.ClientResult result = this.InternalProtocol(body, null);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, then the protocol method should be internal. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003Cglobal::UnbrandedTypeSpec.Models.Thing\u003E\u003E InternalProtocolAsync(global::UnbrandedTypeSpec.Models.Thing body)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(body, nameof(body));\n\n            global::System.ClientModel.ClientResult result = await this.InternalProtocolAsync(body, null).ConfigureAwait(false);\n            return global::System.ClientModel.ClientResult.FromValue(((global::UnbrandedTypeSpec.Models.Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult StillConvenient(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateStillConvenientRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E StillConvenientAsync(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateStillConvenientRequest(options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult StillConvenient()\n        {\n            return this.StillConvenient(null);\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E StillConvenientAsync()\n        {\n            return await this.StillConvenientAsync(null).ConfigureAwait(false);\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] head as boolean.\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult HeadAsBoolean(string id, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(id, nameof(id));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHeadAsBooleanRequest(id, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] head as boolean.\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E HeadAsBooleanAsync(string id, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(id, nameof(id));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateHeadAsBooleanRequest(id, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E head as boolean. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult HeadAsBoolean(string id)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(id, nameof(id));\n\n            return this.HeadAsBoolean(id, null);\n        }\n\n        /// \u003Csummary\u003E head as boolean. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E HeadAsBooleanAsync(string id)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(id, nameof(id));\n\n            return await this.HeadAsBooleanAsync(id, null).ConfigureAwait(false);\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual global::System.ClientModel.ClientResult WithApiVersion(string p1, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateWithApiVersionRequest(p1, options);\n            return global::System.ClientModel.ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E WithApiVersionAsync(string p1, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n\n            using global::System.ClientModel.Primitives.PipelineMessage message = this.CreateWithApiVersionRequest(p1, options);\n            return global::System.ClientModel.ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual global::System.ClientModel.ClientResult WithApiVersion(string p1)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n\n            return this.WithApiVersion(p1, null);\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022global::System.ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022global::System.ClientModel.ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async global::System.Threading.Tasks.Task\u003Cglobal::System.ClientModel.ClientResult\u003E WithApiVersionAsync(string p1)\n        {\n            global::UnbrandedTypeSpec.Argument.AssertNotNull(p1, nameof(p1));\n\n            return await this.WithApiVersionAsync(p1, null).ConfigureAwait(false);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "UnbrandedTypeSpecClient.RestClient.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecClient",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\n\nnamespace UnbrandedTypeSpec\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class UnbrandedTypeSpecClient\n    {\n        private static global::System.ClientModel.Primitives.PipelineMessageClassifier _pipelineMessageClassifier200;\n        private static global::System.ClientModel.Primitives.PipelineMessageClassifier _pipelineMessageClassifier201;\n        private static global::System.ClientModel.Primitives.PipelineMessageClassifier _pipelineMessageClassifier204;\n        private static global::UnbrandedTypeSpec.UnbrandedTypeSpecClient.Classifier2xxAnd4xx _pipelineMessageClassifier2xxAnd4xx;\n\n        private static global::System.ClientModel.Primitives.PipelineMessageClassifier PipelineMessageClassifier200 =\u003E _pipelineMessageClassifier200 = global::System.ClientModel.Primitives.PipelineMessageClassifier.Create(stackalloc ushort[] { 200 });\n\n        private static global::System.ClientModel.Primitives.PipelineMessageClassifier PipelineMessageClassifier201 =\u003E _pipelineMessageClassifier201 = global::System.ClientModel.Primitives.PipelineMessageClassifier.Create(stackalloc ushort[] { 201 });\n\n        private static global::System.ClientModel.Primitives.PipelineMessageClassifier PipelineMessageClassifier204 =\u003E _pipelineMessageClassifier204 = global::System.ClientModel.Primitives.PipelineMessageClassifier.Create(stackalloc ushort[] { 204 });\n\n        private static global::UnbrandedTypeSpec.UnbrandedTypeSpecClient.Classifier2xxAnd4xx PipelineMessageClassifier2xxAnd4xx =\u003E _pipelineMessageClassifier2xxAnd4xx ??= new global::UnbrandedTypeSpec.UnbrandedTypeSpecClient.Classifier2xxAnd4xx();\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateSayHiRequest(string headParameter, string queryParameter, string optionalQuery, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/hello\u0022, false);\n            uri.AppendQuery(\u0022queryParameter\u0022, queryParameter, true);\n            if ((optionalQuery != null))\n            {\n                uri.AppendQuery(\u0022optionalQuery\u0022, optionalQuery, true);\n            }\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022head-parameter\u0022, headParameter);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateHelloAgainRequest(string p2, string p1, global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/againHi/\u0022, false);\n            uri.AppendPath(p2, true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, p1);\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022text/plain\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateNoContentTypeRequest(string p2, string p1, global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/noContentType/\u0022, false);\n            uri.AppendPath(p2, true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, p1);\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateHelloDemo2Request(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/demoHi\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateCreateLiteralRequest(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/literal\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateHelloLiteralRequest(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/helloLiteral/\u0022, false);\n            uri.AppendPath(123.ToString(), true);\n            uri.AppendQuery(\u0022p3\u0022, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(true, null), true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, \u0022test\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateTopActionRequest(global::System.DateTimeOffset action, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/top/\u0022, false);\n            uri.AppendPath(action.ToString(\u0022O\u0022), true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateTopAction2Request(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/top2\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreatePatchActionRequest(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022PATCH\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/patch\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateAnonymousBodyRequest(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/anonymousBody\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateFriendlyModelRequest(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/friendlyName\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateAddTimeHeaderRequest(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier204;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Repeatability-First-Sent\u0022, global::UnbrandedTypeSpec.TypeFormatters.ConvertToString(global::System.DateTimeOffset.Now, \u0022R\u0022));\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateProjectedNameModelRequest(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/projectedName\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateReturnsAnonymousModelRequest(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/returnsAnonymousModel\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateGetUnknownValueRequest(string accept, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/unknown-value\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, accept);\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateInternalProtocolRequest(global::System.ClientModel.BinaryContent content, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/internalProtocol\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateStillConvenientRequest(global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier204;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/stillConvenient\u0022, false);\n            request.Uri = uri.ToUri();\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateHeadAsBooleanRequest(string id, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier2xxAnd4xx;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022HEAD\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/headAsBoolean/\u0022, false);\n            uri.AppendPath(id, true);\n            request.Uri = uri.ToUri();\n            message.Apply(options);\n            return message;\n        }\n\n        internal global::System.ClientModel.Primitives.PipelineMessage CreateWithApiVersionRequest(string p1, global::System.ClientModel.Primitives.RequestOptions options)\n        {\n            global::System.ClientModel.Primitives.PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier204;\n            global::System.ClientModel.Primitives.PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            global::UnbrandedTypeSpec.ClientUriBuilder uri = new global::UnbrandedTypeSpec.ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/WithApiVersion\u0022, false);\n            uri.AppendQuery(\u0022apiVersion\u0022, _apiVersion, true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, p1);\n            message.Apply(options);\n            return message;\n        }\n\n        private class Classifier2xxAnd4xx : global::System.ClientModel.Primitives.PipelineMessageClassifier\n        {\n            public override bool TryClassify(global::System.ClientModel.Primitives.PipelineMessage message, out bool isError)\n            {\n                isError = false;\n                if ((message.Response == null))\n                {\n                    return false;\n                }\n                isError = message.Response.Status switch\n                {\n                    ((\u003E= 200) and (\u003C 300)) =\u003E false,\n                    ((\u003E= 400) and (\u003C 500)) =\u003E false,\n                    _ =\u003E true\n                };\n                return true;\n            }\n\n            public override bool TryClassify(global::System.ClientModel.Primitives.PipelineMessage message, global::System.Exception exception, out bool isRetryable)\n            {\n                isRetryable = false;\n                return false;\n            }\n        }\n    }\n}\n"
          }
        },
        {
          "name": "UnbrandedTypeSpecClientOptions.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecClientOptions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel.Primitives;\n\nnamespace UnbrandedTypeSpec\n{\n    /// \u003Csummary\u003E Client options for \u003Csee cref=\u0022global::UnbrandedTypeSpec.UnbrandedTypeSpecClient\u0022/\u003E. \u003C/summary\u003E\n    public partial class UnbrandedTypeSpecClientOptions : global::System.ClientModel.Primitives.ClientPipelineOptions\n    {\n        private const global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions.ServiceVersion LatestVersion = global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions.ServiceVersion.V2024_08_16_Preview;\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClientOptions. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022version\u0022\u003E The service version. \u003C/param\u003E\n        public UnbrandedTypeSpecClientOptions(global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions.ServiceVersion version = LatestVersion)\n        {\n            Version = version switch\n            {\n                global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions.ServiceVersion.V2024_07_16_Preview =\u003E \u00222024-07-16-preview\u0022,\n                global::UnbrandedTypeSpec.UnbrandedTypeSpecClientOptions.ServiceVersion.V2024_08_16_Preview =\u003E \u00222024-08-16-preview\u0022,\n                _ =\u003E throw new global::System.NotSupportedException()\n            };\n        }\n\n        internal string Version { get; }\n\n        /// \u003Csummary\u003E The version of the service to use. \u003C/summary\u003E\n        public enum ServiceVersion\n        {\n            /// \u003Csummary\u003E V2024_07_16_Preview. \u003C/summary\u003E\n            V2024_07_16_Preview = 1,\n            /// \u003Csummary\u003E V2024_08_16_Preview. \u003C/summary\u003E\n            V2024_08_16_Preview = 2\n        }\n    }\n}\n"
          }
        }
      ]
    }
  ]
}