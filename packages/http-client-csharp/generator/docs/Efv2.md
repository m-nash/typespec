# Summary

When generating clients there are three `views` that need to be taken into account in order to generate a more accurate client.
- `Spec View`: This matches exactly what the spec says to create including any customizations in client.tsp.
- `Custom Code View`: This is completely custom code that library authors will write to augement what would be generated by the spec alone.  Typically these are customizations that can't be done in client.tsp like method body implementations or language specific property type changes.
- `Last GA Contract View`:  This matches exactly what the last GA version of the library looked like.  It does not match the last version of the spec because there could have been custom code involved as well as some versions of the spec do get skipped on occasion.

All three of these views get combined using various logic to create the final product that is backwards compatible and follows the standards for a given language.

# Scenarios

## Spec Only

This scenario will show a very simple spec only generation.

<details>
  <summary>Example</summary>
  
  Lets start with a simple typespec with 1 model and one operation
  
  ```tsp
  namespace Store;
  
  model Foo {
    x: int;
  }
  
  op method(...Foo) : Foo;
  ```
  
  This will generate the following client code
  
  ```c#
  public partial class Foo
  {
    public int X { get; set; }
  }
  
  public partial class StoreClient
  {
    public ClientResult<Foo> Method(int x, CancellationToken token = default)
    {
      Foo foo = new Foo()
      {
        X = x
      }
      //send foo to the service
    }
  }
  ```
</details>
  
## Spec with custom overload
  
This example shows how the custom code can change what gets generated when adding an overload which takes the model instead of the spread.
  
<details>
  <summary>Example</summary>
  
  Lets start with a simple typespec with 1 model and one operation
  
  ```tsp
  namespace Store;
  
  model Foo {
    x: int;
  }
  
  op method(...Foo) : Foo;
  ```
  
  Lets also define the custom code which adds the overload
  
  ```c#
  public partial class StoreClient
  {
    //no need to define the body of the method since the generation can take care of this part.
    public ClientResult<Foo> Method(Foo foo, CancellationToken token = default) => throw null;
  }
  ```
  
  Using the custom code the generator will make some different choices on the implementation of what was in the spec.
  
  ```c#
  public partial class Foo
  {
    public int X { get; set; }
  }
  
  public partial class StoreClient
  {
    public ClientResult<Foo> Method(int x, CancellationToken token = default)
    {
      Foo foo = new Foo()
      {
        X = x
      }
      return Method(foo, token);
    }
  
    public ClientResult<Foo> Method(Foo foo, CancellationToken token = default)
    {
      //send foo to the service
    }
  }
  ```
</details>
  
## Spec with backwards compatibility issue in second version
  
In this scenario we first generate a client from a spec and GA that client.  Later the spec will change and we will need to generate a new client.
We will need to inspect the last GA contract in order to determine what to generate so that we create a backwards compatible result.

<details>
  <summary>Example</summary>
  
  We first start with a very simple spec for v1.
  
  ```tsp
  namespace Store;
  
  model Foo {
    x: int;
  }
  
  op method(...Foo) : Foo;
  ```
  
  This will generate the following client code
  
  ```c#
  public partial class Foo
  {
    public int X { get; set; }
  }
  
  public partial class StoreClient
  {
    public ClientResult<Foo> Method(int x, CancellationToken token = default)
    {
      Foo foo = new Foo()
      {
        X = x
      }
      //send foo to the service
    }
  }
  ```
  
  Next we introduce a new optional property to the Foo model in v2.
  
  ```tsp
  namespace Store;
  
  model Foo {
    x: int;
    y?: int;
  }
  
  op method(...Foo) : Foo;
  ```
  
  If we just use the spec this will result in a backwards compatibility issue since we will introduce a new optional parameter that isn't at the end of the method.
  
  ```c#
  public ClientResult<Foo> Method(int x, int? y = null, CancellationToken token = default)
  ```
  
  Using the last contract view we can detect this and automatically generate a client that would be backwards compatible and that would look like this.
  
  ```c#
  public partial class Foo
  {
    public int X { get; set; }
  }
  
  public partial class StoreClient
  {
    public ClientResult<Foo> Method(int x, CancellationToken token)
    {
      return Method(x, null, token);
    }
  
    public ClientResult<Foo> Method(int x, int? y = null, CancellationToken token = default)
    {
      Foo foo = new Foo()
      {
        X = x,
        Y = y
      }
      //send foo to the service
    }
  }
  ```
</details>

# Solution to explore

The main gap we have when considering the goals [here](https://loop.cloud.microsoft/p/eyJ1IjoiaHR0cHM6Ly9taWNyb3NvZnQuc2hhcmVwb2ludC5jb20vc2l0ZXMvNGI4Y2Q1NmItNmQ0MC00YWIzLWJlYTUtMTc0NGQ0ZDczY2RmP25hdj1jejBsTWtaemFYUmxjeVV5UmpSaU9HTmtOVFppTFRaa05EQXROR0ZpTXkxaVpXRTFMVEUzTkRSa05HUTNNMk5rWmlaa1BXSWxNakZ2Y1dWcE5VTmtVMm93VTBKb01VSnVMVkZRVGpKeFN6QllWbkJQYVdGR1VHaHpaMUJVYUVkU1RuUnZORE5qTTFKTE1VMDVVWEEwVDFaeFpsVjNiMlZwSm1ZOU1ERlZVVmRGV1ZCTlFVSlRTRmRRVFVKRFJGSkZNbE5TTTBGWVFWY3lRVFpDVlNaalBTVXlSaVpoUFV4dmIzQkJjSEFtY0QwbE5EQm1iSFZwWkhnbE1rWnNiMjl3TFhCaFoyVXRZMjl1ZEdGcGJtVnlKbmc5SlRkQ0pUSXlkeVV5TWlVelFTVXlNbFF3VWxSVlNIaDBZVmRPZVdJelRuWmFibEYxWXpKb2FHTnRWbmRpTW14MVpFTTFhbUl5TVRoWmFVWjJZMWRXY0U1VlRtdFZNbTkzVlRCS2IwMVZTblZNVmtaUlZHcEtlRk42UWxsV2JrSlFZVmRHUjFWSGFIcGFNVUpWWVVWa1UxUnVVblpPUkU1cVRURktURTFWTURWVldFRXdWREZhZUZwc1ZqTmlNbFp3WmtSQmVGWldSbGhTVm14UlZGVmFTVlF4WkVST1JYaFlWbXh2TVZGVmJFWldlbVJOVXpCMFQxSkZPVTlVZWtrbE0wUWxNaklsTWtNbE1qSnBKVEl5SlROQkpUSXlZV1UxWVRCbU9UTXRPRGhtTlMwMFpXVmhMV0ZpTkRrdE16bGtPV1ZrTkdRNE5UQmpKVEl5SlRkRSJ9?ct=1728577817115&&LOF=1) is that a customer who learns
how to extend or compose their customizations in one language would not be able to directly apply those learnings to doing the same task in another language.  Ensuring that all emitters produce alloy components and utilize EFv2 to emit those into code files will allow us to provide this consistency across languages.

The main challenge for non javascript languages is we rely heavily on language specific tools and re-writing those tools in javascript would introduce a significant implementation and maintenance cost.

One solution to this would be to modify the existing out of proc generator to instead of emitting code files to disk write an alloy component representation to disk.  This could then be loaded back in by the emitter, used to construct all the alloy components in memory, and finally send that to EFv2 to write out the *.cs files.  Anyone composing or extending would be able to do so as if there was no out of proc step.

```mermaid
sequenceDiagram
    participant A as tsp
    participant B as Emitter
    participant C as TCGC
    participant D as EFv2
    participant E as Generator
    A->>B: onEmit(context)
    B->>C: createSdkContext(context)
    C->>B: SdkPackage
    Note right of B: Client centric typegraph
    B->>B: Save codeModel.json to disk
    Note right of B: Serialize SdkPackage typegraph
    B->>E: dotnet run mgc.dll
    E->>E: Deserialize codeModel.json to InputTypes
    E->>E: Convert InputTypes to dotnet idiomatic OutputTypes
    Note right of E: 85% of the logic to create the library is here
    E->>E: Save alloy-components.json to disk
    Note right of E: Write an alloy representation of the OutputTypes
    E->>B: success
    B->>B: Construct alloy components from file
    B->>D: Emit alloy components
    D->>D: Write *.cs files to disk
    D->>B: success
    B->>A: success
```

This solution allows us to still depend on the language specific tooling while still accomplishing the goals of having a consistent story for all languages.  The format of the alloy-components.json file would look something like this.

```json

{
  "folders": [
    {
      "name": "src",
      "files": [
        {
          "name": "Model.cs",
          "kind": "model",
          "classes": [
            {
              "name": "Model",
              "properties": [
              ],
              "methods": [
              ]
            }
          ]
        },
        {
          "name": "Model.serialization.cs",
          "kind": "model-serialization",
          "classes": [
            {
              "name": "Model",
              "properties": [
              ],
              "methods": [
              ]
            }
          ]
        },
        {
          "name": "Client.cs",
          "kind": "client",
          "classes": [
            {
              "name": "Client",
              "properties": [
              ],
              "methods": [
              ]
            }
          ]
        }
      ]
    }
  ]
}

```

Each component would be represented by an object in the json structure which would make this easy to convert back into actual alloy components in the emitter like this.

```js

  return (
    <ay.Output namePolicy={csNamePolicy}>
      <cs.SourceDirectory directories={alloy.folders}>
        <cs.File files={alloy.files}>
          <cs.Model models={alloy.files.filter((m) => m.kind === "model")} />
          <cs.ModelSerialization models={alloy.files.filter((m) => m.kind === "model-serialization")} />
          <cs.Client models={alloy.files.filter((m) => m.kind === "model")} />
        </cs.File>
      </cs.SourceDirectory>
    </ay.Output>
  );

```